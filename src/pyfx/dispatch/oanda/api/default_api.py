# coding: utf-8

from pydantic import validate_arguments
from typing_extensions import Annotated
from typing import overload, Optional, Union, Awaitable

from pydantic import Field, StrictBool, StrictInt, StrictStr, conlist

from ..models.cancel_order200_response import CancelOrder200Response
from ..models.close_position200_response import ClosePosition200Response
from ..models.close_position_request import ClosePositionRequest
from ..models.close_trade200_response import CloseTrade200Response
from ..models.close_trade_request import CloseTradeRequest
from ..models.configure_account200_response import ConfigureAccount200Response
from ..models.configure_account_request import ConfigureAccountRequest
from ..models.create_order201_response import CreateOrder201Response
from ..models.create_order_request import CreateOrderRequest
from ..models.get_account200_response import GetAccount200Response
from ..models.get_account_changes200_response import GetAccountChanges200Response
from ..models.get_account_instruments200_response import GetAccountInstruments200Response
from ..models.get_account_summary200_response import GetAccountSummary200Response
from ..models.get_external_user_info200_response import GetExternalUserInfo200Response
from ..models.get_instrument_candles200_response import GetInstrumentCandles200Response
from ..models.get_instrument_price200_response import GetInstrumentPrice200Response
from ..models.get_instrument_price_range200_response import GetInstrumentPriceRange200Response
from ..models.get_order200_response import GetOrder200Response
from ..models.get_position200_response import GetPosition200Response
from ..models.get_prices200_response import GetPrices200Response
from ..models.get_trade200_response import GetTrade200Response
from ..models.get_transaction200_response import GetTransaction200Response
from ..models.get_transaction_range200_response import GetTransactionRange200Response
from ..models.get_user_info200_response import GetUserInfo200Response
from ..models.instruments_instrument_order_book_get200_response import InstrumentsInstrumentOrderBookGet200Response
from ..models.instruments_instrument_position_book_get200_response import InstrumentsInstrumentPositionBookGet200Response
from ..models.list_accounts200_response import ListAccounts200Response
from ..models.list_open_positions200_response import ListOpenPositions200Response
from ..models.list_open_trades200_response import ListOpenTrades200Response
from ..models.list_orders200_response import ListOrders200Response
from ..models.list_pending_orders200_response import ListPendingOrders200Response
from ..models.list_positions200_response import ListPositions200Response
from ..models.list_trades200_response import ListTrades200Response
from ..models.list_transactions200_response import ListTransactions200Response
from ..models.replace_order201_response import ReplaceOrder201Response
from ..models.set_order_client_extensions200_response import SetOrderClientExtensions200Response
from ..models.set_order_client_extensions_request import SetOrderClientExtensionsRequest
from ..models.set_trade_client_extensions200_response import SetTradeClientExtensions200Response
from ..models.set_trade_client_extensions_request import SetTradeClientExtensionsRequest
from ..models.set_trade_dependent_orders200_response import SetTradeDependentOrders200Response
from ..models.set_trade_dependent_orders_request import SetTradeDependentOrdersRequest
from ..models.stream_pricing200_response import StreamPricing200Response
from ..models.stream_transactions200_response import StreamTransactions200Response

from ..api_client import ApiClient
from ..api_response import ApiResponse
from ..exceptions import ApiTypeError
from ..request_constants import RequestMethod


class DefaultApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech
    """

    def __init__(self, api_client: ApiClient):
        self.api_client = api_client

    @overload
    async def cancel_order(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], order_specifier : Annotated[StrictStr, Field(..., description="The Order Specifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, client_request_id : Annotated[Optional[StrictStr], Field(description="Client specified RequestID to be sent with request.")] = None, **kwargs) -> CancelOrder200Response:  # noqa: E501
        ...

    @overload
    def cancel_order(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], order_specifier : Annotated[StrictStr, Field(..., description="The Order Specifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, client_request_id : Annotated[Optional[StrictStr], Field(description="Client specified RequestID to be sent with request.")] = None, **kwargs) -> CancelOrder200Response:  # noqa: E501
        ...

    @validate_arguments
    def cancel_order(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], order_specifier : Annotated[StrictStr, Field(..., description="The Order Specifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, client_request_id : Annotated[Optional[StrictStr], Field(description="Client specified RequestID to be sent with request.")] = None, **kwargs) -> Union[CancelOrder200Response, Awaitable[CancelOrder200Response]]:  # noqa: E501
        """Cancel Order  # noqa: E501

        Cancel a pending Order in an Account  # noqa: E501

        >>> response = api.cancel_order(authorization, account_id, order_specifier, accept_datetime_format, client_request_id)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param order_specifier: The Order Specifier (required)
        :type order_specifier: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param client_request_id: Client specified RequestID to be sent with request.
        :type client_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: CancelOrder200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the cancel_order_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.cancel_order_with_http_info(authorization, account_id, order_specifier, accept_datetime_format, client_request_id, **kwargs)  # noqa: E501

    @validate_arguments
    def cancel_order_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], order_specifier : Annotated[StrictStr, Field(..., description="The Order Specifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, client_request_id : Annotated[Optional[StrictStr], Field(description="Client specified RequestID to be sent with request.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Cancel Order  # noqa: E501

        Cancel a pending Order in an Account  # noqa: E501

        >>> response = api.cancel_order_with_http_info(authorization, account_id, order_specifier, accept_datetime_format, client_request_id)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param order_specifier: The Order Specifier (required)
        :type order_specifier: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param client_request_id: Client specified RequestID to be sent with request.
        :type client_request_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(CancelOrder200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'order_specifier',
            'accept_datetime_format',
            'client_request_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method cancel_order" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']

        if _params['order_specifier']:
            _path_params['orderSpecifier'] = _params['order_specifier']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        if _params['client_request_id']:
            _header_params['ClientRequestID'] = _params['client_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "CancelOrder200Response",
            '401': "GetInstrumentCandles400Response",
            '404': "CancelOrder404Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/orders/{orderSpecifier}/cancel', RequestMethod.PUT,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def close_position(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], close_position_body : Annotated[ClosePositionRequest, Field(..., description="Representation of how to close the position")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> ClosePosition200Response:  # noqa: E501
        ...

    @overload
    def close_position(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], close_position_body : Annotated[ClosePositionRequest, Field(..., description="Representation of how to close the position")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> ClosePosition200Response:  # noqa: E501
        ...

    @validate_arguments
    def close_position(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], close_position_body : Annotated[ClosePositionRequest, Field(..., description="Representation of how to close the position")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> Union[ClosePosition200Response, Awaitable[ClosePosition200Response]]:  # noqa: E501
        """Close Position  # noqa: E501

        Closeout the open Position for a specific instrument in an Account.  # noqa: E501

        >>> response = api.close_position(authorization, account_id, instrument, close_position_body, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param instrument: Name of the Instrument (required)
        :type instrument: str
        :param close_position_body: Representation of how to close the position (required)
        :type close_position_body: ClosePositionRequest
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: ClosePosition200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the close_position_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.close_position_with_http_info(authorization, account_id, instrument, close_position_body, accept_datetime_format, **kwargs)  # noqa: E501

    @validate_arguments
    def close_position_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], close_position_body : Annotated[ClosePositionRequest, Field(..., description="Representation of how to close the position")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Close Position  # noqa: E501

        Closeout the open Position for a specific instrument in an Account.  # noqa: E501

        >>> response = api.close_position_with_http_info(authorization, account_id, instrument, close_position_body, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param instrument: Name of the Instrument (required)
        :type instrument: str
        :param close_position_body: Representation of how to close the position (required)
        :type close_position_body: ClosePositionRequest
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(ClosePosition200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'instrument',
            'close_position_body',
            'accept_datetime_format'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method close_position" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']

        if _params['instrument']:
            _path_params['instrument'] = _params['instrument']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['close_position_body'] is not None:
            _body_params = _params['close_position_body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ClosePosition200Response",
            '400': "ClosePosition400Response",
            '401': "GetInstrumentCandles400Response",
            '404': "ClosePosition404Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/positions/{instrument}/close', RequestMethod.PUT,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def close_trade(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], trade_specifier : Annotated[StrictStr, Field(..., description="Specifier for the Trade")], close_trade_body : Annotated[CloseTradeRequest, Field(..., description="Details of how much of the open Trade to close.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> CloseTrade200Response:  # noqa: E501
        ...

    @overload
    def close_trade(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], trade_specifier : Annotated[StrictStr, Field(..., description="Specifier for the Trade")], close_trade_body : Annotated[CloseTradeRequest, Field(..., description="Details of how much of the open Trade to close.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> CloseTrade200Response:  # noqa: E501
        ...

    @validate_arguments
    def close_trade(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], trade_specifier : Annotated[StrictStr, Field(..., description="Specifier for the Trade")], close_trade_body : Annotated[CloseTradeRequest, Field(..., description="Details of how much of the open Trade to close.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> Union[CloseTrade200Response, Awaitable[CloseTrade200Response]]:  # noqa: E501
        """Close Trade  # noqa: E501

        Close (partially or fully) a specific open Trade in an Account  # noqa: E501

        >>> response = api.close_trade(authorization, account_id, trade_specifier, close_trade_body, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param trade_specifier: Specifier for the Trade (required)
        :type trade_specifier: str
        :param close_trade_body: Details of how much of the open Trade to close. (required)
        :type close_trade_body: CloseTradeRequest
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: CloseTrade200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the close_trade_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.close_trade_with_http_info(authorization, account_id, trade_specifier, close_trade_body, accept_datetime_format, **kwargs)  # noqa: E501

    @validate_arguments
    def close_trade_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], trade_specifier : Annotated[StrictStr, Field(..., description="Specifier for the Trade")], close_trade_body : Annotated[CloseTradeRequest, Field(..., description="Details of how much of the open Trade to close.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Close Trade  # noqa: E501

        Close (partially or fully) a specific open Trade in an Account  # noqa: E501

        >>> response = api.close_trade_with_http_info(authorization, account_id, trade_specifier, close_trade_body, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param trade_specifier: Specifier for the Trade (required)
        :type trade_specifier: str
        :param close_trade_body: Details of how much of the open Trade to close. (required)
        :type close_trade_body: CloseTradeRequest
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(CloseTrade200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'trade_specifier',
            'close_trade_body',
            'accept_datetime_format'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method close_trade" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']

        if _params['trade_specifier']:
            _path_params['tradeSpecifier'] = _params['trade_specifier']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['close_trade_body'] is not None:
            _body_params = _params['close_trade_body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "CloseTrade200Response",
            '400': "CloseTrade400Response",
            '401': "GetInstrumentCandles400Response",
            '404': "CloseTrade404Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/trades/{tradeSpecifier}/close', RequestMethod.PUT,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def configure_account(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, configure_account_body : Annotated[Optional[ConfigureAccountRequest], Field(description="Representation of the Account configuration to set")] = None, **kwargs) -> ConfigureAccount200Response:  # noqa: E501
        ...

    @overload
    def configure_account(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, configure_account_body : Annotated[Optional[ConfigureAccountRequest], Field(description="Representation of the Account configuration to set")] = None, **kwargs) -> ConfigureAccount200Response:  # noqa: E501
        ...

    @validate_arguments
    def configure_account(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, configure_account_body : Annotated[Optional[ConfigureAccountRequest], Field(description="Representation of the Account configuration to set")] = None, **kwargs) -> Union[ConfigureAccount200Response, Awaitable[ConfigureAccount200Response]]:  # noqa: E501
        """Configure Account  # noqa: E501

        Set the client-configurable portions of an Account.  # noqa: E501

        >>> response = api.configure_account(authorization, account_id, accept_datetime_format, configure_account_body)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param configure_account_body: Representation of the Account configuration to set
        :type configure_account_body: ConfigureAccountRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: ConfigureAccount200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the configure_account_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.configure_account_with_http_info(authorization, account_id, accept_datetime_format, configure_account_body, **kwargs)  # noqa: E501

    @validate_arguments
    def configure_account_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, configure_account_body : Annotated[Optional[ConfigureAccountRequest], Field(description="Representation of the Account configuration to set")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Configure Account  # noqa: E501

        Set the client-configurable portions of an Account.  # noqa: E501

        >>> response = api.configure_account_with_http_info(authorization, account_id, accept_datetime_format, configure_account_body)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param configure_account_body: Representation of the Account configuration to set
        :type configure_account_body: ConfigureAccountRequest
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(ConfigureAccount200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'accept_datetime_format',
            'configure_account_body'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method configure_account" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['configure_account_body'] is not None:
            _body_params = _params['configure_account_body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ConfigureAccount200Response",
            '400': "ConfigureAccount400Response",
            '403': "ConfigureAccount400Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/configuration', RequestMethod.PATCH,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def create_order(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], create_order_body : CreateOrderRequest, accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> CreateOrder201Response:  # noqa: E501
        ...

    @overload
    def create_order(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], create_order_body : CreateOrderRequest, accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> CreateOrder201Response:  # noqa: E501
        ...

    @validate_arguments
    def create_order(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], create_order_body : CreateOrderRequest, accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> Union[CreateOrder201Response, Awaitable[CreateOrder201Response]]:  # noqa: E501
        """Create Order  # noqa: E501

        Create an Order for an Account  # noqa: E501

        >>> response = api.create_order(authorization, account_id, create_order_body, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param create_order_body: (required)
        :type create_order_body: CreateOrderRequest
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: CreateOrder201Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the create_order_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.create_order_with_http_info(authorization, account_id, create_order_body, accept_datetime_format, **kwargs)  # noqa: E501

    @validate_arguments
    def create_order_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], create_order_body : CreateOrderRequest, accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create Order  # noqa: E501

        Create an Order for an Account  # noqa: E501

        >>> response = api.create_order_with_http_info(authorization, account_id, create_order_body, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param create_order_body: (required)
        :type create_order_body: CreateOrderRequest
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(CreateOrder201Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'create_order_body',
            'accept_datetime_format'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method create_order" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['create_order_body'] is not None:
            _body_params = _params['create_order_body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '201': "CreateOrder201Response",
            '400': "CreateOrder400Response",
            '401': "GetInstrumentCandles400Response",
            '403': "GetInstrumentCandles400Response",
            '404': "CreateOrder404Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/orders', RequestMethod.POST,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_account(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> GetAccount200Response:  # noqa: E501
        ...

    @overload
    def get_account(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> GetAccount200Response:  # noqa: E501
        ...

    @validate_arguments
    def get_account(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> Union[GetAccount200Response, Awaitable[GetAccount200Response]]:  # noqa: E501
        """Account Details  # noqa: E501

        Get the full details for a single Account that a client has access to. Full pending Order, open Trade and open Position representations are provided.  # noqa: E501

        >>> response = api.get_account(authorization, account_id, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: GetAccount200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_account_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_account_with_http_info(authorization, account_id, accept_datetime_format, **kwargs)  # noqa: E501

    @validate_arguments
    def get_account_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Account Details  # noqa: E501

        Get the full details for a single Account that a client has access to. Full pending Order, open Trade and open Position representations are provided.  # noqa: E501

        >>> response = api.get_account_with_http_info(authorization, account_id, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(GetAccount200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'accept_datetime_format'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method get_account" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetAccount200Response",
            '400': "GetInstrumentCandles400Response",
            '401': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_account_changes(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, since_transaction_id : Annotated[Optional[StrictStr], Field(description="ID of the Transaction to get Account changes since.")] = None, **kwargs) -> GetAccountChanges200Response:  # noqa: E501
        ...

    @overload
    def get_account_changes(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, since_transaction_id : Annotated[Optional[StrictStr], Field(description="ID of the Transaction to get Account changes since.")] = None, **kwargs) -> GetAccountChanges200Response:  # noqa: E501
        ...

    @validate_arguments
    def get_account_changes(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, since_transaction_id : Annotated[Optional[StrictStr], Field(description="ID of the Transaction to get Account changes since.")] = None, **kwargs) -> Union[GetAccountChanges200Response, Awaitable[GetAccountChanges200Response]]:  # noqa: E501
        """Poll Account Updates  # noqa: E501

        Endpoint used to poll an Account for its current state and changes since a specified TransactionID.  # noqa: E501

        >>> response = api.get_account_changes(authorization, account_id, accept_datetime_format, since_transaction_id)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param since_transaction_id: ID of the Transaction to get Account changes since.
        :type since_transaction_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: GetAccountChanges200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_account_changes_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_account_changes_with_http_info(authorization, account_id, accept_datetime_format, since_transaction_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_account_changes_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, since_transaction_id : Annotated[Optional[StrictStr], Field(description="ID of the Transaction to get Account changes since.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Poll Account Updates  # noqa: E501

        Endpoint used to poll an Account for its current state and changes since a specified TransactionID.  # noqa: E501

        >>> response = api.get_account_changes_with_http_info(authorization, account_id, accept_datetime_format, since_transaction_id)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param since_transaction_id: ID of the Transaction to get Account changes since.
        :type since_transaction_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(GetAccountChanges200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'accept_datetime_format',
            'since_transaction_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method get_account_changes" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']


        # process the query parameters
        _query_params = []
        if _params.get('since_transaction_id') is not None:  # noqa: E501
            _query_params.append(('sinceTransactionID', _params['since_transaction_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetAccountChanges200Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
            '416': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/changes', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_account_instruments(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], instruments : Annotated[Optional[conlist(StrictStr)], Field(description="List of instruments to query specifically.")] = None, **kwargs) -> GetAccountInstruments200Response:  # noqa: E501
        ...

    @overload
    def get_account_instruments(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], instruments : Annotated[Optional[conlist(StrictStr)], Field(description="List of instruments to query specifically.")] = None, **kwargs) -> GetAccountInstruments200Response:  # noqa: E501
        ...

    @validate_arguments
    def get_account_instruments(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], instruments : Annotated[Optional[conlist(StrictStr)], Field(description="List of instruments to query specifically.")] = None, **kwargs) -> Union[GetAccountInstruments200Response, Awaitable[GetAccountInstruments200Response]]:  # noqa: E501
        """Account Instruments  # noqa: E501

        Get the list of tradeable instruments for the given Account. The list of tradeable instruments is dependent on the regulatory division that the Account is located in, thus should be the same for all Accounts owned by a single user.  # noqa: E501

        >>> response = api.get_account_instruments(authorization, account_id, instruments)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param instruments: List of instruments to query specifically.
        :type instruments: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: GetAccountInstruments200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_account_instruments_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_account_instruments_with_http_info(authorization, account_id, instruments, **kwargs)  # noqa: E501

    @validate_arguments
    def get_account_instruments_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], instruments : Annotated[Optional[conlist(StrictStr)], Field(description="List of instruments to query specifically.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Account Instruments  # noqa: E501

        Get the list of tradeable instruments for the given Account. The list of tradeable instruments is dependent on the regulatory division that the Account is located in, thus should be the same for all Accounts owned by a single user.  # noqa: E501

        >>> response = api.get_account_instruments_with_http_info(authorization, account_id, instruments)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param instruments: List of instruments to query specifically.
        :type instruments: List[str]
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(GetAccountInstruments200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'instruments'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method get_account_instruments" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']


        # process the query parameters
        _query_params = []
        if _params.get('instruments') is not None:  # noqa: E501
            _query_params.append(('instruments', _params['instruments']))
            _collection_formats['instruments'] = 'csv'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetAccountInstruments200Response",
            '400': "GetInstrumentCandles400Response",
            '401': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/instruments', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_account_summary(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> GetAccountSummary200Response:  # noqa: E501
        ...

    @overload
    def get_account_summary(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> GetAccountSummary200Response:  # noqa: E501
        ...

    @validate_arguments
    def get_account_summary(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> Union[GetAccountSummary200Response, Awaitable[GetAccountSummary200Response]]:  # noqa: E501
        """Account Summary  # noqa: E501

        Get a summary for a single Account that a client has access to.  # noqa: E501

        >>> response = api.get_account_summary(authorization, account_id, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: GetAccountSummary200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_account_summary_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_account_summary_with_http_info(authorization, account_id, accept_datetime_format, **kwargs)  # noqa: E501

    @validate_arguments
    def get_account_summary_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Account Summary  # noqa: E501

        Get a summary for a single Account that a client has access to.  # noqa: E501

        >>> response = api.get_account_summary_with_http_info(authorization, account_id, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(GetAccountSummary200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'accept_datetime_format'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method get_account_summary" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetAccountSummary200Response",
            '400': "GetInstrumentCandles400Response",
            '401': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/summary', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_base_prices(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, time : Annotated[Optional[StrictStr], Field(description="The time at which the desired price for each instrument is in effect. The current price for each instrument is returned if no time is provided.")] = None, **kwargs) -> GetInstrumentPriceRange200Response:  # noqa: E501
        ...

    @overload
    def get_base_prices(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, time : Annotated[Optional[StrictStr], Field(description="The time at which the desired price for each instrument is in effect. The current price for each instrument is returned if no time is provided.")] = None, **kwargs) -> GetInstrumentPriceRange200Response:  # noqa: E501
        ...

    @validate_arguments
    def get_base_prices(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, time : Annotated[Optional[StrictStr], Field(description="The time at which the desired price for each instrument is in effect. The current price for each instrument is returned if no time is provided.")] = None, **kwargs) -> Union[GetInstrumentPriceRange200Response, Awaitable[GetInstrumentPriceRange200Response]]:  # noqa: E501
        """Get Base Prices  # noqa: E501

        Get pricing information for a specified instrument. Accounts are not associated in any way with this endpoint.  # noqa: E501

        >>> response = api.get_base_prices(authorization, accept_datetime_format, time)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param time: The time at which the desired price for each instrument is in effect. The current price for each instrument is returned if no time is provided.
        :type time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: GetInstrumentPriceRange200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_base_prices_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_base_prices_with_http_info(authorization, accept_datetime_format, time, **kwargs)  # noqa: E501

    @validate_arguments
    def get_base_prices_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, time : Annotated[Optional[StrictStr], Field(description="The time at which the desired price for each instrument is in effect. The current price for each instrument is returned if no time is provided.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Base Prices  # noqa: E501

        Get pricing information for a specified instrument. Accounts are not associated in any way with this endpoint.  # noqa: E501

        >>> response = api.get_base_prices_with_http_info(authorization, accept_datetime_format, time)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param time: The time at which the desired price for each instrument is in effect. The current price for each instrument is returned if no time is provided.
        :type time: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(GetInstrumentPriceRange200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'accept_datetime_format',
            'time'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method get_base_prices" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('time') is not None:  # noqa: E501
            _query_params.append(('time', _params['time']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetInstrumentPriceRange200Response",
            '400': "GetInstrumentCandles400Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/pricing', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_external_user_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], user_specifier : Annotated[StrictStr, Field(..., description="The User Specifier")], **kwargs) -> GetExternalUserInfo200Response:  # noqa: E501
        ...

    @overload
    def get_external_user_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], user_specifier : Annotated[StrictStr, Field(..., description="The User Specifier")], **kwargs) -> GetExternalUserInfo200Response:  # noqa: E501
        ...

    @validate_arguments
    def get_external_user_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], user_specifier : Annotated[StrictStr, Field(..., description="The User Specifier")], **kwargs) -> Union[GetExternalUserInfo200Response, Awaitable[GetExternalUserInfo200Response]]:  # noqa: E501
        """External User Info  # noqa: E501

        Fetch the externally-available user information for the specified user. This endpoint is intended to be used by 3rd parties that have been authorized by a user to view their personal information.  # noqa: E501

        >>> response = api.get_external_user_info(authorization, user_specifier)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param user_specifier: The User Specifier (required)
        :type user_specifier: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: GetExternalUserInfo200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_external_user_info_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_external_user_info_with_http_info(authorization, user_specifier, **kwargs)  # noqa: E501

    @validate_arguments
    def get_external_user_info_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], user_specifier : Annotated[StrictStr, Field(..., description="The User Specifier")], **kwargs) -> ApiResponse:  # noqa: E501
        """External User Info  # noqa: E501

        Fetch the externally-available user information for the specified user. This endpoint is intended to be used by 3rd parties that have been authorized by a user to view their personal information.  # noqa: E501

        >>> response = api.get_external_user_info_with_http_info(authorization, user_specifier)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param user_specifier: The User Specifier (required)
        :type user_specifier: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(GetExternalUserInfo200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'user_specifier'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method get_external_user_info" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['user_specifier']:
            _path_params['userSpecifier'] = _params['user_specifier']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetExternalUserInfo200Response",
            '401': "GetInstrumentCandles400Response",
            '403': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/users/{userSpecifier}/externalInfo', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_instrument_candles(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, price : Annotated[Optional[StrictStr], Field(description="The Price component(s) to get candlestick data for. Can contain any combination of the characters \"M\" (midpoint candles) \"B\" (bid candles) and \"A\" (ask candles).")] = None, granularity : Annotated[Optional[StrictStr], Field(description="The granularity of the candlesticks to fetch")] = None, count : Annotated[Optional[StrictInt], Field(description="The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return.")] = None, var_from : Annotated[Optional[StrictStr], Field(description="The start of the time range to fetch candlesticks for.")] = None, to : Annotated[Optional[StrictStr], Field(description="The end of the time range to fetch candlesticks for.")] = None, smooth : Annotated[Optional[StrictBool], Field(description="A flag that controls whether the candlestick is \"smoothed\" or not.  A smoothed candlestick uses the previous candle's close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price.")] = None, include_first : Annotated[Optional[StrictBool], Field(description="A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly.")] = None, daily_alignment : Annotated[Optional[StrictInt], Field(description="The hour of the day (in the specified timezone) to use for granularities that have daily alignments.")] = None, alignment_timezone : Annotated[Optional[StrictStr], Field(description="The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC.")] = None, weekly_alignment : Annotated[Optional[StrictStr], Field(description="The day of the week used for granularities that have weekly alignment.")] = None, **kwargs) -> GetInstrumentCandles200Response:  # noqa: E501
        ...

    @overload
    def get_instrument_candles(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, price : Annotated[Optional[StrictStr], Field(description="The Price component(s) to get candlestick data for. Can contain any combination of the characters \"M\" (midpoint candles) \"B\" (bid candles) and \"A\" (ask candles).")] = None, granularity : Annotated[Optional[StrictStr], Field(description="The granularity of the candlesticks to fetch")] = None, count : Annotated[Optional[StrictInt], Field(description="The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return.")] = None, var_from : Annotated[Optional[StrictStr], Field(description="The start of the time range to fetch candlesticks for.")] = None, to : Annotated[Optional[StrictStr], Field(description="The end of the time range to fetch candlesticks for.")] = None, smooth : Annotated[Optional[StrictBool], Field(description="A flag that controls whether the candlestick is \"smoothed\" or not.  A smoothed candlestick uses the previous candle's close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price.")] = None, include_first : Annotated[Optional[StrictBool], Field(description="A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly.")] = None, daily_alignment : Annotated[Optional[StrictInt], Field(description="The hour of the day (in the specified timezone) to use for granularities that have daily alignments.")] = None, alignment_timezone : Annotated[Optional[StrictStr], Field(description="The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC.")] = None, weekly_alignment : Annotated[Optional[StrictStr], Field(description="The day of the week used for granularities that have weekly alignment.")] = None, **kwargs) -> GetInstrumentCandles200Response:  # noqa: E501
        ...

    @validate_arguments
    def get_instrument_candles(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, price : Annotated[Optional[StrictStr], Field(description="The Price component(s) to get candlestick data for. Can contain any combination of the characters \"M\" (midpoint candles) \"B\" (bid candles) and \"A\" (ask candles).")] = None, granularity : Annotated[Optional[StrictStr], Field(description="The granularity of the candlesticks to fetch")] = None, count : Annotated[Optional[StrictInt], Field(description="The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return.")] = None, var_from : Annotated[Optional[StrictStr], Field(description="The start of the time range to fetch candlesticks for.")] = None, to : Annotated[Optional[StrictStr], Field(description="The end of the time range to fetch candlesticks for.")] = None, smooth : Annotated[Optional[StrictBool], Field(description="A flag that controls whether the candlestick is \"smoothed\" or not.  A smoothed candlestick uses the previous candle's close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price.")] = None, include_first : Annotated[Optional[StrictBool], Field(description="A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly.")] = None, daily_alignment : Annotated[Optional[StrictInt], Field(description="The hour of the day (in the specified timezone) to use for granularities that have daily alignments.")] = None, alignment_timezone : Annotated[Optional[StrictStr], Field(description="The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC.")] = None, weekly_alignment : Annotated[Optional[StrictStr], Field(description="The day of the week used for granularities that have weekly alignment.")] = None, **kwargs) -> Union[GetInstrumentCandles200Response, Awaitable[GetInstrumentCandles200Response]]:  # noqa: E501
        """Get Candlesticks  # noqa: E501

        Fetch candlestick data for an instrument.  # noqa: E501

        >>> response = api.get_instrument_candles(authorization, instrument, accept_datetime_format, price, granularity, count, var_from, to, smooth, include_first, daily_alignment, alignment_timezone, weekly_alignment)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param instrument: Name of the Instrument (required)
        :type instrument: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param price: The Price component(s) to get candlestick data for. Can contain any combination of the characters \"M\" (midpoint candles) \"B\" (bid candles) and \"A\" (ask candles).
        :type price: str
        :param granularity: The granularity of the candlesticks to fetch
        :type granularity: str
        :param count: The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return.
        :type count: int
        :param var_from: The start of the time range to fetch candlesticks for.
        :type var_from: str
        :param to: The end of the time range to fetch candlesticks for.
        :type to: str
        :param smooth: A flag that controls whether the candlestick is \"smoothed\" or not.  A smoothed candlestick uses the previous candle's close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price.
        :type smooth: bool
        :param include_first: A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly.
        :type include_first: bool
        :param daily_alignment: The hour of the day (in the specified timezone) to use for granularities that have daily alignments.
        :type daily_alignment: int
        :param alignment_timezone: The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC.
        :type alignment_timezone: str
        :param weekly_alignment: The day of the week used for granularities that have weekly alignment.
        :type weekly_alignment: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: GetInstrumentCandles200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_instrument_candles_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_instrument_candles_with_http_info(authorization, instrument, accept_datetime_format, price, granularity, count, var_from, to, smooth, include_first, daily_alignment, alignment_timezone, weekly_alignment, **kwargs)  # noqa: E501

    @validate_arguments
    def get_instrument_candles_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, price : Annotated[Optional[StrictStr], Field(description="The Price component(s) to get candlestick data for. Can contain any combination of the characters \"M\" (midpoint candles) \"B\" (bid candles) and \"A\" (ask candles).")] = None, granularity : Annotated[Optional[StrictStr], Field(description="The granularity of the candlesticks to fetch")] = None, count : Annotated[Optional[StrictInt], Field(description="The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return.")] = None, var_from : Annotated[Optional[StrictStr], Field(description="The start of the time range to fetch candlesticks for.")] = None, to : Annotated[Optional[StrictStr], Field(description="The end of the time range to fetch candlesticks for.")] = None, smooth : Annotated[Optional[StrictBool], Field(description="A flag that controls whether the candlestick is \"smoothed\" or not.  A smoothed candlestick uses the previous candle's close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price.")] = None, include_first : Annotated[Optional[StrictBool], Field(description="A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly.")] = None, daily_alignment : Annotated[Optional[StrictInt], Field(description="The hour of the day (in the specified timezone) to use for granularities that have daily alignments.")] = None, alignment_timezone : Annotated[Optional[StrictStr], Field(description="The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC.")] = None, weekly_alignment : Annotated[Optional[StrictStr], Field(description="The day of the week used for granularities that have weekly alignment.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Candlesticks  # noqa: E501

        Fetch candlestick data for an instrument.  # noqa: E501

        >>> response = api.get_instrument_candles_with_http_info(authorization, instrument, accept_datetime_format, price, granularity, count, var_from, to, smooth, include_first, daily_alignment, alignment_timezone, weekly_alignment)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param instrument: Name of the Instrument (required)
        :type instrument: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param price: The Price component(s) to get candlestick data for. Can contain any combination of the characters \"M\" (midpoint candles) \"B\" (bid candles) and \"A\" (ask candles).
        :type price: str
        :param granularity: The granularity of the candlesticks to fetch
        :type granularity: str
        :param count: The number of candlesticks to return in the reponse. Count should not be specified if both the start and end parameters are provided, as the time range combined with the graularity will determine the number of candlesticks to return.
        :type count: int
        :param var_from: The start of the time range to fetch candlesticks for.
        :type var_from: str
        :param to: The end of the time range to fetch candlesticks for.
        :type to: str
        :param smooth: A flag that controls whether the candlestick is \"smoothed\" or not.  A smoothed candlestick uses the previous candle's close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price.
        :type smooth: bool
        :param include_first: A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly.
        :type include_first: bool
        :param daily_alignment: The hour of the day (in the specified timezone) to use for granularities that have daily alignments.
        :type daily_alignment: int
        :param alignment_timezone: The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC.
        :type alignment_timezone: str
        :param weekly_alignment: The day of the week used for granularities that have weekly alignment.
        :type weekly_alignment: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(GetInstrumentCandles200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'instrument',
            'accept_datetime_format',
            'price',
            'granularity',
            'count',
            'var_from',
            'to',
            'smooth',
            'include_first',
            'daily_alignment',
            'alignment_timezone',
            'weekly_alignment'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method get_instrument_candles" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['instrument']:
            _path_params['instrument'] = _params['instrument']


        # process the query parameters
        _query_params = []
        if _params.get('price') is not None:  # noqa: E501
            _query_params.append(('price', _params['price']))

        if _params.get('granularity') is not None:  # noqa: E501
            _query_params.append(('granularity', _params['granularity']))

        if _params.get('count') is not None:  # noqa: E501
            _query_params.append(('count', _params['count']))

        if _params.get('var_from') is not None:  # noqa: E501
            _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            _query_params.append(('to', _params['to']))

        if _params.get('smooth') is not None:  # noqa: E501
            _query_params.append(('smooth', _params['smooth']))

        if _params.get('include_first') is not None:  # noqa: E501
            _query_params.append(('includeFirst', _params['include_first']))

        if _params.get('daily_alignment') is not None:  # noqa: E501
            _query_params.append(('dailyAlignment', _params['daily_alignment']))

        if _params.get('alignment_timezone') is not None:  # noqa: E501
            _query_params.append(('alignmentTimezone', _params['alignment_timezone']))

        if _params.get('weekly_alignment') is not None:  # noqa: E501
            _query_params.append(('weeklyAlignment', _params['weekly_alignment']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetInstrumentCandles200Response",
            '400': "GetInstrumentCandles400Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/instruments/{instrument}/candles', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_instrument_candles_0(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, price : Annotated[Optional[StrictStr], Field(description="The Price component(s) to get candlestick data for. Can contain any combination of the characters \"M\" (midpoint candles) \"B\" (bid candles) and \"A\" (ask candles).")] = None, granularity : Annotated[Optional[StrictStr], Field(description="The granularity of the candlesticks to fetch")] = None, count : Annotated[Optional[StrictInt], Field(description="The number of candlesticks to return in the response. Count should not be specified if both the start and end parameters are provided, as the time range combined with the granularity will determine the number of candlesticks to return.")] = None, var_from : Annotated[Optional[StrictStr], Field(description="The start of the time range to fetch candlesticks for.")] = None, to : Annotated[Optional[StrictStr], Field(description="The end of the time range to fetch candlesticks for.")] = None, smooth : Annotated[Optional[StrictBool], Field(description="A flag that controls whether the candlestick is \"smoothed\" or not.  A smoothed candlestick uses the previous candle's close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price.")] = None, include_first : Annotated[Optional[StrictBool], Field(description="A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly.")] = None, daily_alignment : Annotated[Optional[StrictInt], Field(description="The hour of the day (in the specified timezone) to use for granularities that have daily alignments.")] = None, alignment_timezone : Annotated[Optional[StrictStr], Field(description="The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC.")] = None, weekly_alignment : Annotated[Optional[StrictStr], Field(description="The day of the week used for granularities that have weekly alignment.")] = None, units : Annotated[Optional[StrictStr], Field(description="The number of units used to calculate the volume-weighted average bid and ask prices in the returned candles.")] = None, **kwargs) -> GetInstrumentCandles200Response:  # noqa: E501
        ...

    @overload
    def get_instrument_candles_0(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, price : Annotated[Optional[StrictStr], Field(description="The Price component(s) to get candlestick data for. Can contain any combination of the characters \"M\" (midpoint candles) \"B\" (bid candles) and \"A\" (ask candles).")] = None, granularity : Annotated[Optional[StrictStr], Field(description="The granularity of the candlesticks to fetch")] = None, count : Annotated[Optional[StrictInt], Field(description="The number of candlesticks to return in the response. Count should not be specified if both the start and end parameters are provided, as the time range combined with the granularity will determine the number of candlesticks to return.")] = None, var_from : Annotated[Optional[StrictStr], Field(description="The start of the time range to fetch candlesticks for.")] = None, to : Annotated[Optional[StrictStr], Field(description="The end of the time range to fetch candlesticks for.")] = None, smooth : Annotated[Optional[StrictBool], Field(description="A flag that controls whether the candlestick is \"smoothed\" or not.  A smoothed candlestick uses the previous candle's close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price.")] = None, include_first : Annotated[Optional[StrictBool], Field(description="A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly.")] = None, daily_alignment : Annotated[Optional[StrictInt], Field(description="The hour of the day (in the specified timezone) to use for granularities that have daily alignments.")] = None, alignment_timezone : Annotated[Optional[StrictStr], Field(description="The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC.")] = None, weekly_alignment : Annotated[Optional[StrictStr], Field(description="The day of the week used for granularities that have weekly alignment.")] = None, units : Annotated[Optional[StrictStr], Field(description="The number of units used to calculate the volume-weighted average bid and ask prices in the returned candles.")] = None, **kwargs) -> GetInstrumentCandles200Response:  # noqa: E501
        ...

    @validate_arguments
    def get_instrument_candles_0(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, price : Annotated[Optional[StrictStr], Field(description="The Price component(s) to get candlestick data for. Can contain any combination of the characters \"M\" (midpoint candles) \"B\" (bid candles) and \"A\" (ask candles).")] = None, granularity : Annotated[Optional[StrictStr], Field(description="The granularity of the candlesticks to fetch")] = None, count : Annotated[Optional[StrictInt], Field(description="The number of candlesticks to return in the response. Count should not be specified if both the start and end parameters are provided, as the time range combined with the granularity will determine the number of candlesticks to return.")] = None, var_from : Annotated[Optional[StrictStr], Field(description="The start of the time range to fetch candlesticks for.")] = None, to : Annotated[Optional[StrictStr], Field(description="The end of the time range to fetch candlesticks for.")] = None, smooth : Annotated[Optional[StrictBool], Field(description="A flag that controls whether the candlestick is \"smoothed\" or not.  A smoothed candlestick uses the previous candle's close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price.")] = None, include_first : Annotated[Optional[StrictBool], Field(description="A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly.")] = None, daily_alignment : Annotated[Optional[StrictInt], Field(description="The hour of the day (in the specified timezone) to use for granularities that have daily alignments.")] = None, alignment_timezone : Annotated[Optional[StrictStr], Field(description="The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC.")] = None, weekly_alignment : Annotated[Optional[StrictStr], Field(description="The day of the week used for granularities that have weekly alignment.")] = None, units : Annotated[Optional[StrictStr], Field(description="The number of units used to calculate the volume-weighted average bid and ask prices in the returned candles.")] = None, **kwargs) -> Union[GetInstrumentCandles200Response, Awaitable[GetInstrumentCandles200Response]]:  # noqa: E501
        """Get Candlesticks  # noqa: E501

        Fetch candlestick data for an instrument.  # noqa: E501

        >>> response = api.get_instrument_candles_0(authorization, instrument, accept_datetime_format, price, granularity, count, var_from, to, smooth, include_first, daily_alignment, alignment_timezone, weekly_alignment, units)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param instrument: Name of the Instrument (required)
        :type instrument: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param price: The Price component(s) to get candlestick data for. Can contain any combination of the characters \"M\" (midpoint candles) \"B\" (bid candles) and \"A\" (ask candles).
        :type price: str
        :param granularity: The granularity of the candlesticks to fetch
        :type granularity: str
        :param count: The number of candlesticks to return in the response. Count should not be specified if both the start and end parameters are provided, as the time range combined with the granularity will determine the number of candlesticks to return.
        :type count: int
        :param var_from: The start of the time range to fetch candlesticks for.
        :type var_from: str
        :param to: The end of the time range to fetch candlesticks for.
        :type to: str
        :param smooth: A flag that controls whether the candlestick is \"smoothed\" or not.  A smoothed candlestick uses the previous candle's close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price.
        :type smooth: bool
        :param include_first: A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly.
        :type include_first: bool
        :param daily_alignment: The hour of the day (in the specified timezone) to use for granularities that have daily alignments.
        :type daily_alignment: int
        :param alignment_timezone: The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC.
        :type alignment_timezone: str
        :param weekly_alignment: The day of the week used for granularities that have weekly alignment.
        :type weekly_alignment: str
        :param units: The number of units used to calculate the volume-weighted average bid and ask prices in the returned candles.
        :type units: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: GetInstrumentCandles200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_instrument_candles_0_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_instrument_candles_0_with_http_info(authorization, instrument, accept_datetime_format, price, granularity, count, var_from, to, smooth, include_first, daily_alignment, alignment_timezone, weekly_alignment, units, **kwargs)  # noqa: E501

    @validate_arguments
    def get_instrument_candles_0_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, price : Annotated[Optional[StrictStr], Field(description="The Price component(s) to get candlestick data for. Can contain any combination of the characters \"M\" (midpoint candles) \"B\" (bid candles) and \"A\" (ask candles).")] = None, granularity : Annotated[Optional[StrictStr], Field(description="The granularity of the candlesticks to fetch")] = None, count : Annotated[Optional[StrictInt], Field(description="The number of candlesticks to return in the response. Count should not be specified if both the start and end parameters are provided, as the time range combined with the granularity will determine the number of candlesticks to return.")] = None, var_from : Annotated[Optional[StrictStr], Field(description="The start of the time range to fetch candlesticks for.")] = None, to : Annotated[Optional[StrictStr], Field(description="The end of the time range to fetch candlesticks for.")] = None, smooth : Annotated[Optional[StrictBool], Field(description="A flag that controls whether the candlestick is \"smoothed\" or not.  A smoothed candlestick uses the previous candle's close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price.")] = None, include_first : Annotated[Optional[StrictBool], Field(description="A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly.")] = None, daily_alignment : Annotated[Optional[StrictInt], Field(description="The hour of the day (in the specified timezone) to use for granularities that have daily alignments.")] = None, alignment_timezone : Annotated[Optional[StrictStr], Field(description="The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC.")] = None, weekly_alignment : Annotated[Optional[StrictStr], Field(description="The day of the week used for granularities that have weekly alignment.")] = None, units : Annotated[Optional[StrictStr], Field(description="The number of units used to calculate the volume-weighted average bid and ask prices in the returned candles.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Candlesticks  # noqa: E501

        Fetch candlestick data for an instrument.  # noqa: E501

        >>> response = api.get_instrument_candles_0_with_http_info(authorization, instrument, accept_datetime_format, price, granularity, count, var_from, to, smooth, include_first, daily_alignment, alignment_timezone, weekly_alignment, units)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param instrument: Name of the Instrument (required)
        :type instrument: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param price: The Price component(s) to get candlestick data for. Can contain any combination of the characters \"M\" (midpoint candles) \"B\" (bid candles) and \"A\" (ask candles).
        :type price: str
        :param granularity: The granularity of the candlesticks to fetch
        :type granularity: str
        :param count: The number of candlesticks to return in the response. Count should not be specified if both the start and end parameters are provided, as the time range combined with the granularity will determine the number of candlesticks to return.
        :type count: int
        :param var_from: The start of the time range to fetch candlesticks for.
        :type var_from: str
        :param to: The end of the time range to fetch candlesticks for.
        :type to: str
        :param smooth: A flag that controls whether the candlestick is \"smoothed\" or not.  A smoothed candlestick uses the previous candle's close price as its open price, while an unsmoothed candlestick uses the first price from its time range as its open price.
        :type smooth: bool
        :param include_first: A flag that controls whether the candlestick that is covered by the from time should be included in the results. This flag enables clients to use the timestamp of the last completed candlestick received to poll for future candlesticks but avoid receiving the previous candlestick repeatedly.
        :type include_first: bool
        :param daily_alignment: The hour of the day (in the specified timezone) to use for granularities that have daily alignments.
        :type daily_alignment: int
        :param alignment_timezone: The timezone to use for the dailyAlignment parameter. Candlesticks with daily alignment will be aligned to the dailyAlignment hour within the alignmentTimezone.  Note that the returned times will still be represented in UTC.
        :type alignment_timezone: str
        :param weekly_alignment: The day of the week used for granularities that have weekly alignment.
        :type weekly_alignment: str
        :param units: The number of units used to calculate the volume-weighted average bid and ask prices in the returned candles.
        :type units: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(GetInstrumentCandles200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'instrument',
            'accept_datetime_format',
            'price',
            'granularity',
            'count',
            'var_from',
            'to',
            'smooth',
            'include_first',
            'daily_alignment',
            'alignment_timezone',
            'weekly_alignment',
            'units'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method get_instrument_candles_0" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['instrument']:
            _path_params['instrument'] = _params['instrument']


        # process the query parameters
        _query_params = []
        if _params.get('price') is not None:  # noqa: E501
            _query_params.append(('price', _params['price']))

        if _params.get('granularity') is not None:  # noqa: E501
            _query_params.append(('granularity', _params['granularity']))

        if _params.get('count') is not None:  # noqa: E501
            _query_params.append(('count', _params['count']))

        if _params.get('var_from') is not None:  # noqa: E501
            _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            _query_params.append(('to', _params['to']))

        if _params.get('smooth') is not None:  # noqa: E501
            _query_params.append(('smooth', _params['smooth']))

        if _params.get('include_first') is not None:  # noqa: E501
            _query_params.append(('includeFirst', _params['include_first']))

        if _params.get('daily_alignment') is not None:  # noqa: E501
            _query_params.append(('dailyAlignment', _params['daily_alignment']))

        if _params.get('alignment_timezone') is not None:  # noqa: E501
            _query_params.append(('alignmentTimezone', _params['alignment_timezone']))

        if _params.get('weekly_alignment') is not None:  # noqa: E501
            _query_params.append(('weeklyAlignment', _params['weekly_alignment']))

        if _params.get('units') is not None:  # noqa: E501
            _query_params.append(('units', _params['units']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetInstrumentCandles200Response",
            '400': "GetInstrumentCandles400Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/instruments/{instrument}/candles', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_instrument_price(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, time : Annotated[Optional[StrictStr], Field(description="The time at which the desired price is in effect. The current price is returned if no time is provided.")] = None, **kwargs) -> GetInstrumentPrice200Response:  # noqa: E501
        ...

    @overload
    def get_instrument_price(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, time : Annotated[Optional[StrictStr], Field(description="The time at which the desired price is in effect. The current price is returned if no time is provided.")] = None, **kwargs) -> GetInstrumentPrice200Response:  # noqa: E501
        ...

    @validate_arguments
    def get_instrument_price(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, time : Annotated[Optional[StrictStr], Field(description="The time at which the desired price is in effect. The current price is returned if no time is provided.")] = None, **kwargs) -> Union[GetInstrumentPrice200Response, Awaitable[GetInstrumentPrice200Response]]:  # noqa: E501
        """Price  # noqa: E501

        Fetch a price for an instrument. Accounts are not associated in any way with this endpoint.  # noqa: E501

        >>> response = api.get_instrument_price(authorization, instrument, accept_datetime_format, time)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param instrument: Name of the Instrument (required)
        :type instrument: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param time: The time at which the desired price is in effect. The current price is returned if no time is provided.
        :type time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: GetInstrumentPrice200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_instrument_price_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_instrument_price_with_http_info(authorization, instrument, accept_datetime_format, time, **kwargs)  # noqa: E501

    @validate_arguments
    def get_instrument_price_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, time : Annotated[Optional[StrictStr], Field(description="The time at which the desired price is in effect. The current price is returned if no time is provided.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Price  # noqa: E501

        Fetch a price for an instrument. Accounts are not associated in any way with this endpoint.  # noqa: E501

        >>> response = api.get_instrument_price_with_http_info(authorization, instrument, accept_datetime_format, time)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param instrument: Name of the Instrument (required)
        :type instrument: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param time: The time at which the desired price is in effect. The current price is returned if no time is provided.
        :type time: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(GetInstrumentPrice200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'instrument',
            'accept_datetime_format',
            'time'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method get_instrument_price" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['instrument']:
            _path_params['instrument'] = _params['instrument']


        # process the query parameters
        _query_params = []
        if _params.get('time') is not None:  # noqa: E501
            _query_params.append(('time', _params['time']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetInstrumentPrice200Response",
            '400': "GetInstrumentCandles400Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/instruments/{instrument}/price', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_instrument_price_range(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], var_from : Annotated[StrictStr, Field(..., description="The start of the time range to fetch prices for.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, to : Annotated[Optional[StrictStr], Field(description="The end of the time range to fetch prices for. The current time is used if this parameter is not provided.")] = None, **kwargs) -> GetInstrumentPriceRange200Response:  # noqa: E501
        ...

    @overload
    def get_instrument_price_range(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], var_from : Annotated[StrictStr, Field(..., description="The start of the time range to fetch prices for.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, to : Annotated[Optional[StrictStr], Field(description="The end of the time range to fetch prices for. The current time is used if this parameter is not provided.")] = None, **kwargs) -> GetInstrumentPriceRange200Response:  # noqa: E501
        ...

    @validate_arguments
    def get_instrument_price_range(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], var_from : Annotated[StrictStr, Field(..., description="The start of the time range to fetch prices for.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, to : Annotated[Optional[StrictStr], Field(description="The end of the time range to fetch prices for. The current time is used if this parameter is not provided.")] = None, **kwargs) -> Union[GetInstrumentPriceRange200Response, Awaitable[GetInstrumentPriceRange200Response]]:  # noqa: E501
        """Get Prices  # noqa: E501

        Fetch a range of prices for an instrument. Accounts are not associated in any way with this endpoint.  # noqa: E501

        >>> response = api.get_instrument_price_range(authorization, instrument, var_from, accept_datetime_format, to)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param instrument: Name of the Instrument (required)
        :type instrument: str
        :param var_from: The start of the time range to fetch prices for. (required)
        :type var_from: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param to: The end of the time range to fetch prices for. The current time is used if this parameter is not provided.
        :type to: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: GetInstrumentPriceRange200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_instrument_price_range_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_instrument_price_range_with_http_info(authorization, instrument, var_from, accept_datetime_format, to, **kwargs)  # noqa: E501

    @validate_arguments
    def get_instrument_price_range_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], var_from : Annotated[StrictStr, Field(..., description="The start of the time range to fetch prices for.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, to : Annotated[Optional[StrictStr], Field(description="The end of the time range to fetch prices for. The current time is used if this parameter is not provided.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Prices  # noqa: E501

        Fetch a range of prices for an instrument. Accounts are not associated in any way with this endpoint.  # noqa: E501

        >>> response = api.get_instrument_price_range_with_http_info(authorization, instrument, var_from, accept_datetime_format, to)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param instrument: Name of the Instrument (required)
        :type instrument: str
        :param var_from: The start of the time range to fetch prices for. (required)
        :type var_from: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param to: The end of the time range to fetch prices for. The current time is used if this parameter is not provided.
        :type to: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(GetInstrumentPriceRange200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'instrument',
            'var_from',
            'accept_datetime_format',
            'to'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method get_instrument_price_range" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['instrument']:
            _path_params['instrument'] = _params['instrument']


        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            _query_params.append(('to', _params['to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetInstrumentPriceRange200Response",
            '400': "GetInstrumentCandles400Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/instruments/{instrument}/price/range', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_order(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], order_specifier : Annotated[StrictStr, Field(..., description="The Order Specifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> GetOrder200Response:  # noqa: E501
        ...

    @overload
    def get_order(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], order_specifier : Annotated[StrictStr, Field(..., description="The Order Specifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> GetOrder200Response:  # noqa: E501
        ...

    @validate_arguments
    def get_order(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], order_specifier : Annotated[StrictStr, Field(..., description="The Order Specifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> Union[GetOrder200Response, Awaitable[GetOrder200Response]]:  # noqa: E501
        """Get Order  # noqa: E501

        Get details for a single Order in an Account  # noqa: E501

        >>> response = api.get_order(authorization, account_id, order_specifier, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param order_specifier: The Order Specifier (required)
        :type order_specifier: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: GetOrder200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_order_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_order_with_http_info(authorization, account_id, order_specifier, accept_datetime_format, **kwargs)  # noqa: E501

    @validate_arguments
    def get_order_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], order_specifier : Annotated[StrictStr, Field(..., description="The Order Specifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Order  # noqa: E501

        Get details for a single Order in an Account  # noqa: E501

        >>> response = api.get_order_with_http_info(authorization, account_id, order_specifier, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param order_specifier: The Order Specifier (required)
        :type order_specifier: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(GetOrder200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'order_specifier',
            'accept_datetime_format'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method get_order" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']

        if _params['order_specifier']:
            _path_params['orderSpecifier'] = _params['order_specifier']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetOrder200Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/orders/{orderSpecifier}', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_position(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], **kwargs) -> GetPosition200Response:  # noqa: E501
        ...

    @overload
    def get_position(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], **kwargs) -> GetPosition200Response:  # noqa: E501
        ...

    @validate_arguments
    def get_position(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], **kwargs) -> Union[GetPosition200Response, Awaitable[GetPosition200Response]]:  # noqa: E501
        """Instrument Position  # noqa: E501

        Get the details of a single Instrument's Position in an Account. The Position may by open or not.  # noqa: E501

        >>> response = api.get_position(authorization, account_id, instrument)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param instrument: Name of the Instrument (required)
        :type instrument: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: GetPosition200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_position_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_position_with_http_info(authorization, account_id, instrument, **kwargs)  # noqa: E501

    @validate_arguments
    def get_position_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], **kwargs) -> ApiResponse:  # noqa: E501
        """Instrument Position  # noqa: E501

        Get the details of a single Instrument's Position in an Account. The Position may by open or not.  # noqa: E501

        >>> response = api.get_position_with_http_info(authorization, account_id, instrument)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param instrument: Name of the Instrument (required)
        :type instrument: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(GetPosition200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'instrument'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method get_position" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']

        if _params['instrument']:
            _path_params['instrument'] = _params['instrument']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetPosition200Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/positions/{instrument}', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_price_range(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], var_from : Annotated[StrictStr, Field(..., description="The start of the time range to fetch prices for.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, to : Annotated[Optional[StrictStr], Field(description="The end of the time range to fetch prices for. The current time is used if this parameter is not provided.")] = None, **kwargs) -> GetInstrumentPriceRange200Response:  # noqa: E501
        ...

    @overload
    def get_price_range(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], var_from : Annotated[StrictStr, Field(..., description="The start of the time range to fetch prices for.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, to : Annotated[Optional[StrictStr], Field(description="The end of the time range to fetch prices for. The current time is used if this parameter is not provided.")] = None, **kwargs) -> GetInstrumentPriceRange200Response:  # noqa: E501
        ...

    @validate_arguments
    def get_price_range(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], var_from : Annotated[StrictStr, Field(..., description="The start of the time range to fetch prices for.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, to : Annotated[Optional[StrictStr], Field(description="The end of the time range to fetch prices for. The current time is used if this parameter is not provided.")] = None, **kwargs) -> Union[GetInstrumentPriceRange200Response, Awaitable[GetInstrumentPriceRange200Response]]:  # noqa: E501
        """Get Price Range  # noqa: E501

        Get pricing information for a specified range of prices. Accounts are not associated in any way with this endpoint.  # noqa: E501

        >>> response = api.get_price_range(authorization, instrument, var_from, accept_datetime_format, to)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param instrument: Name of the Instrument (required)
        :type instrument: str
        :param var_from: The start of the time range to fetch prices for. (required)
        :type var_from: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param to: The end of the time range to fetch prices for. The current time is used if this parameter is not provided.
        :type to: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: GetInstrumentPriceRange200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_price_range_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_price_range_with_http_info(authorization, instrument, var_from, accept_datetime_format, to, **kwargs)  # noqa: E501

    @validate_arguments
    def get_price_range_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], var_from : Annotated[StrictStr, Field(..., description="The start of the time range to fetch prices for.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, to : Annotated[Optional[StrictStr], Field(description="The end of the time range to fetch prices for. The current time is used if this parameter is not provided.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Price Range  # noqa: E501

        Get pricing information for a specified range of prices. Accounts are not associated in any way with this endpoint.  # noqa: E501

        >>> response = api.get_price_range_with_http_info(authorization, instrument, var_from, accept_datetime_format, to)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param instrument: Name of the Instrument (required)
        :type instrument: str
        :param var_from: The start of the time range to fetch prices for. (required)
        :type var_from: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param to: The end of the time range to fetch prices for. The current time is used if this parameter is not provided.
        :type to: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(GetInstrumentPriceRange200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'instrument',
            'var_from',
            'accept_datetime_format',
            'to'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method get_price_range" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['instrument']:
            _path_params['instrument'] = _params['instrument']


        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            _query_params.append(('to', _params['to']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetInstrumentPriceRange200Response",
            '400': "GetInstrumentCandles400Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/pricing/range', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_prices(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], instruments : Annotated[conlist(StrictStr), Field(..., description="List of Instruments to get pricing for.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, since : Annotated[Optional[StrictStr], Field(description="Date/Time filter to apply to the response. Only prices and home conversions (if requested) with a time later than this filter (i.e. the price has changed after the since time) will be provided, and are filtered independently.")] = None, include_units_available : Annotated[Optional[StrictBool], Field(description="Flag that enables the inclusion of the unitsAvailable field in the returned Price objects.")] = None, include_home_conversions : Annotated[Optional[StrictBool], Field(description="Flag that enables the inclusion of the homeConversions field in the returned response. An entry will be returned for each currency in the set of all base and quote currencies present in the requested instruments list.")] = None, **kwargs) -> GetPrices200Response:  # noqa: E501
        ...

    @overload
    def get_prices(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], instruments : Annotated[conlist(StrictStr), Field(..., description="List of Instruments to get pricing for.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, since : Annotated[Optional[StrictStr], Field(description="Date/Time filter to apply to the response. Only prices and home conversions (if requested) with a time later than this filter (i.e. the price has changed after the since time) will be provided, and are filtered independently.")] = None, include_units_available : Annotated[Optional[StrictBool], Field(description="Flag that enables the inclusion of the unitsAvailable field in the returned Price objects.")] = None, include_home_conversions : Annotated[Optional[StrictBool], Field(description="Flag that enables the inclusion of the homeConversions field in the returned response. An entry will be returned for each currency in the set of all base and quote currencies present in the requested instruments list.")] = None, **kwargs) -> GetPrices200Response:  # noqa: E501
        ...

    @validate_arguments
    def get_prices(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], instruments : Annotated[conlist(StrictStr), Field(..., description="List of Instruments to get pricing for.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, since : Annotated[Optional[StrictStr], Field(description="Date/Time filter to apply to the response. Only prices and home conversions (if requested) with a time later than this filter (i.e. the price has changed after the since time) will be provided, and are filtered independently.")] = None, include_units_available : Annotated[Optional[StrictBool], Field(description="Flag that enables the inclusion of the unitsAvailable field in the returned Price objects.")] = None, include_home_conversions : Annotated[Optional[StrictBool], Field(description="Flag that enables the inclusion of the homeConversions field in the returned response. An entry will be returned for each currency in the set of all base and quote currencies present in the requested instruments list.")] = None, **kwargs) -> Union[GetPrices200Response, Awaitable[GetPrices200Response]]:  # noqa: E501
        """Current Account Prices  # noqa: E501

        Get pricing information for a specified list of Instruments within an Account.  # noqa: E501

        >>> response = api.get_prices(authorization, account_id, instruments, accept_datetime_format, since, include_units_available, include_home_conversions)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param instruments: List of Instruments to get pricing for. (required)
        :type instruments: List[str]
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param since: Date/Time filter to apply to the response. Only prices and home conversions (if requested) with a time later than this filter (i.e. the price has changed after the since time) will be provided, and are filtered independently.
        :type since: str
        :param include_units_available: Flag that enables the inclusion of the unitsAvailable field in the returned Price objects.
        :type include_units_available: bool
        :param include_home_conversions: Flag that enables the inclusion of the homeConversions field in the returned response. An entry will be returned for each currency in the set of all base and quote currencies present in the requested instruments list.
        :type include_home_conversions: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: GetPrices200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_prices_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_prices_with_http_info(authorization, account_id, instruments, accept_datetime_format, since, include_units_available, include_home_conversions, **kwargs)  # noqa: E501

    @validate_arguments
    def get_prices_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], instruments : Annotated[conlist(StrictStr), Field(..., description="List of Instruments to get pricing for.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, since : Annotated[Optional[StrictStr], Field(description="Date/Time filter to apply to the response. Only prices and home conversions (if requested) with a time later than this filter (i.e. the price has changed after the since time) will be provided, and are filtered independently.")] = None, include_units_available : Annotated[Optional[StrictBool], Field(description="Flag that enables the inclusion of the unitsAvailable field in the returned Price objects.")] = None, include_home_conversions : Annotated[Optional[StrictBool], Field(description="Flag that enables the inclusion of the homeConversions field in the returned response. An entry will be returned for each currency in the set of all base and quote currencies present in the requested instruments list.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Current Account Prices  # noqa: E501

        Get pricing information for a specified list of Instruments within an Account.  # noqa: E501

        >>> response = api.get_prices_with_http_info(authorization, account_id, instruments, accept_datetime_format, since, include_units_available, include_home_conversions)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param instruments: List of Instruments to get pricing for. (required)
        :type instruments: List[str]
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param since: Date/Time filter to apply to the response. Only prices and home conversions (if requested) with a time later than this filter (i.e. the price has changed after the since time) will be provided, and are filtered independently.
        :type since: str
        :param include_units_available: Flag that enables the inclusion of the unitsAvailable field in the returned Price objects.
        :type include_units_available: bool
        :param include_home_conversions: Flag that enables the inclusion of the homeConversions field in the returned response. An entry will be returned for each currency in the set of all base and quote currencies present in the requested instruments list.
        :type include_home_conversions: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(GetPrices200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'instruments',
            'accept_datetime_format',
            'since',
            'include_units_available',
            'include_home_conversions'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method get_prices" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']


        # process the query parameters
        _query_params = []
        if _params.get('instruments') is not None:  # noqa: E501
            _query_params.append(('instruments', _params['instruments']))
            _collection_formats['instruments'] = 'csv'

        if _params.get('since') is not None:  # noqa: E501
            _query_params.append(('since', _params['since']))

        if _params.get('include_units_available') is not None:  # noqa: E501
            _query_params.append(('includeUnitsAvailable', _params['include_units_available']))

        if _params.get('include_home_conversions') is not None:  # noqa: E501
            _query_params.append(('includeHomeConversions', _params['include_home_conversions']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetPrices200Response",
            '400': "GetInstrumentCandles400Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/pricing', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_trade(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], trade_specifier : Annotated[StrictStr, Field(..., description="Specifier for the Trade")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> GetTrade200Response:  # noqa: E501
        ...

    @overload
    def get_trade(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], trade_specifier : Annotated[StrictStr, Field(..., description="Specifier for the Trade")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> GetTrade200Response:  # noqa: E501
        ...

    @validate_arguments
    def get_trade(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], trade_specifier : Annotated[StrictStr, Field(..., description="Specifier for the Trade")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> Union[GetTrade200Response, Awaitable[GetTrade200Response]]:  # noqa: E501
        """Trade Details  # noqa: E501

        Get the details of a specific Trade in an Account  # noqa: E501

        >>> response = api.get_trade(authorization, account_id, trade_specifier, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param trade_specifier: Specifier for the Trade (required)
        :type trade_specifier: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: GetTrade200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_trade_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_trade_with_http_info(authorization, account_id, trade_specifier, accept_datetime_format, **kwargs)  # noqa: E501

    @validate_arguments
    def get_trade_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], trade_specifier : Annotated[StrictStr, Field(..., description="Specifier for the Trade")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Trade Details  # noqa: E501

        Get the details of a specific Trade in an Account  # noqa: E501

        >>> response = api.get_trade_with_http_info(authorization, account_id, trade_specifier, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param trade_specifier: Specifier for the Trade (required)
        :type trade_specifier: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(GetTrade200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'trade_specifier',
            'accept_datetime_format'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method get_trade" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']

        if _params['trade_specifier']:
            _path_params['tradeSpecifier'] = _params['trade_specifier']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetTrade200Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/trades/{tradeSpecifier}', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_transaction(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], transaction_id : Annotated[StrictStr, Field(..., description="A Transaction ID")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> GetTransaction200Response:  # noqa: E501
        ...

    @overload
    def get_transaction(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], transaction_id : Annotated[StrictStr, Field(..., description="A Transaction ID")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> GetTransaction200Response:  # noqa: E501
        ...

    @validate_arguments
    def get_transaction(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], transaction_id : Annotated[StrictStr, Field(..., description="A Transaction ID")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> Union[GetTransaction200Response, Awaitable[GetTransaction200Response]]:  # noqa: E501
        """Transaction Details  # noqa: E501

        Get the details of a single Account Transaction.  # noqa: E501

        >>> response = api.get_transaction(authorization, account_id, transaction_id, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param transaction_id: A Transaction ID (required)
        :type transaction_id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: GetTransaction200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_transaction_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_transaction_with_http_info(authorization, account_id, transaction_id, accept_datetime_format, **kwargs)  # noqa: E501

    @validate_arguments
    def get_transaction_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], transaction_id : Annotated[StrictStr, Field(..., description="A Transaction ID")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Transaction Details  # noqa: E501

        Get the details of a single Account Transaction.  # noqa: E501

        >>> response = api.get_transaction_with_http_info(authorization, account_id, transaction_id, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param transaction_id: A Transaction ID (required)
        :type transaction_id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(GetTransaction200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'transaction_id',
            'accept_datetime_format'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method get_transaction" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']

        if _params['transaction_id']:
            _path_params['transactionID'] = _params['transaction_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetTransaction200Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/transactions/{transactionID}', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_transaction_range(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], var_from : Annotated[StrictStr, Field(..., description="The starting Transacion ID (inclusive) to fetch.")], to : Annotated[StrictStr, Field(..., description="The ending Transaction ID (inclusive) to fetch.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, type : Annotated[Optional[conlist(StrictStr)], Field(description="The filter that restricts the types of Transactions to retreive.")] = None, **kwargs) -> GetTransactionRange200Response:  # noqa: E501
        ...

    @overload
    def get_transaction_range(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], var_from : Annotated[StrictStr, Field(..., description="The starting Transacion ID (inclusive) to fetch.")], to : Annotated[StrictStr, Field(..., description="The ending Transaction ID (inclusive) to fetch.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, type : Annotated[Optional[conlist(StrictStr)], Field(description="The filter that restricts the types of Transactions to retreive.")] = None, **kwargs) -> GetTransactionRange200Response:  # noqa: E501
        ...

    @validate_arguments
    def get_transaction_range(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], var_from : Annotated[StrictStr, Field(..., description="The starting Transacion ID (inclusive) to fetch.")], to : Annotated[StrictStr, Field(..., description="The ending Transaction ID (inclusive) to fetch.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, type : Annotated[Optional[conlist(StrictStr)], Field(description="The filter that restricts the types of Transactions to retreive.")] = None, **kwargs) -> Union[GetTransactionRange200Response, Awaitable[GetTransactionRange200Response]]:  # noqa: E501
        """Transaction ID Range  # noqa: E501

        Get a range of Transactions for an Account based on the Transaction IDs.  # noqa: E501

        >>> response = api.get_transaction_range(authorization, account_id, var_from, to, accept_datetime_format, type)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param var_from: The starting Transacion ID (inclusive) to fetch. (required)
        :type var_from: str
        :param to: The ending Transaction ID (inclusive) to fetch. (required)
        :type to: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param type: The filter that restricts the types of Transactions to retreive.
        :type type: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: GetTransactionRange200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_transaction_range_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_transaction_range_with_http_info(authorization, account_id, var_from, to, accept_datetime_format, type, **kwargs)  # noqa: E501

    @validate_arguments
    def get_transaction_range_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], var_from : Annotated[StrictStr, Field(..., description="The starting Transacion ID (inclusive) to fetch.")], to : Annotated[StrictStr, Field(..., description="The ending Transaction ID (inclusive) to fetch.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, type : Annotated[Optional[conlist(StrictStr)], Field(description="The filter that restricts the types of Transactions to retreive.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Transaction ID Range  # noqa: E501

        Get a range of Transactions for an Account based on the Transaction IDs.  # noqa: E501

        >>> response = api.get_transaction_range_with_http_info(authorization, account_id, var_from, to, accept_datetime_format, type)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param var_from: The starting Transacion ID (inclusive) to fetch. (required)
        :type var_from: str
        :param to: The ending Transaction ID (inclusive) to fetch. (required)
        :type to: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param type: The filter that restricts the types of Transactions to retreive.
        :type type: List[str]
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(GetTransactionRange200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'var_from',
            'to',
            'accept_datetime_format',
            'type'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method get_transaction_range" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']


        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            _query_params.append(('to', _params['to']))

        if _params.get('type') is not None:  # noqa: E501
            _query_params.append(('type', _params['type']))
            _collection_formats['type'] = 'csv'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetTransactionRange200Response",
            '400': "GetInstrumentCandles400Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
            '416': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/transactions/idrange', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_transactions_since_id(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], id : Annotated[StrictStr, Field(..., description="The ID of the last Transacion fetched. This query will return all Transactions newer than the TransactionID.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> GetTransactionRange200Response:  # noqa: E501
        ...

    @overload
    def get_transactions_since_id(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], id : Annotated[StrictStr, Field(..., description="The ID of the last Transacion fetched. This query will return all Transactions newer than the TransactionID.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> GetTransactionRange200Response:  # noqa: E501
        ...

    @validate_arguments
    def get_transactions_since_id(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], id : Annotated[StrictStr, Field(..., description="The ID of the last Transacion fetched. This query will return all Transactions newer than the TransactionID.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> Union[GetTransactionRange200Response, Awaitable[GetTransactionRange200Response]]:  # noqa: E501
        """Transactions Since ID  # noqa: E501

        Get a range of Transactions for an Account starting at (but not including) a provided Transaction ID.  # noqa: E501

        >>> response = api.get_transactions_since_id(authorization, account_id, id, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param id: The ID of the last Transacion fetched. This query will return all Transactions newer than the TransactionID. (required)
        :type id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: GetTransactionRange200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_transactions_since_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_transactions_since_id_with_http_info(authorization, account_id, id, accept_datetime_format, **kwargs)  # noqa: E501

    @validate_arguments
    def get_transactions_since_id_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], id : Annotated[StrictStr, Field(..., description="The ID of the last Transacion fetched. This query will return all Transactions newer than the TransactionID.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Transactions Since ID  # noqa: E501

        Get a range of Transactions for an Account starting at (but not including) a provided Transaction ID.  # noqa: E501

        >>> response = api.get_transactions_since_id_with_http_info(authorization, account_id, id, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param id: The ID of the last Transacion fetched. This query will return all Transactions newer than the TransactionID. (required)
        :type id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(GetTransactionRange200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'id',
            'accept_datetime_format'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method get_transactions_since_id" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']


        # process the query parameters
        _query_params = []
        if _params.get('id') is not None:  # noqa: E501
            _query_params.append(('id', _params['id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetTransactionRange200Response",
            '400': "GetInstrumentCandles400Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
            '416': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/transactions/sinceid', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def get_user_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], user_specifier : Annotated[StrictStr, Field(..., description="The User Specifier")], **kwargs) -> GetUserInfo200Response:  # noqa: E501
        ...

    @overload
    def get_user_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], user_specifier : Annotated[StrictStr, Field(..., description="The User Specifier")], **kwargs) -> GetUserInfo200Response:  # noqa: E501
        ...

    @validate_arguments
    def get_user_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], user_specifier : Annotated[StrictStr, Field(..., description="The User Specifier")], **kwargs) -> Union[GetUserInfo200Response, Awaitable[GetUserInfo200Response]]:  # noqa: E501
        """User Info  # noqa: E501

        Fetch the user information for the specified user. This endpoint is intended to be used by the user themself to obtain their own information.  # noqa: E501

        >>> response = api.get_user_info(authorization, user_specifier)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param user_specifier: The User Specifier (required)
        :type user_specifier: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: GetUserInfo200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_user_info_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_user_info_with_http_info(authorization, user_specifier, **kwargs)  # noqa: E501

    @validate_arguments
    def get_user_info_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], user_specifier : Annotated[StrictStr, Field(..., description="The User Specifier")], **kwargs) -> ApiResponse:  # noqa: E501
        """User Info  # noqa: E501

        Fetch the user information for the specified user. This endpoint is intended to be used by the user themself to obtain their own information.  # noqa: E501

        >>> response = api.get_user_info_with_http_info(authorization, user_specifier)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param user_specifier: The User Specifier (required)
        :type user_specifier: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(GetUserInfo200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'user_specifier'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method get_user_info" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['user_specifier']:
            _path_params['userSpecifier'] = _params['user_specifier']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "GetUserInfo200Response",
            '401': "GetInstrumentCandles400Response",
            '403': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/users/{userSpecifier}', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def instruments_instrument_order_book_get(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, time : Annotated[Optional[StrictStr], Field(description="The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched.")] = None, **kwargs) -> InstrumentsInstrumentOrderBookGet200Response:  # noqa: E501
        ...

    @overload
    def instruments_instrument_order_book_get(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, time : Annotated[Optional[StrictStr], Field(description="The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched.")] = None, **kwargs) -> InstrumentsInstrumentOrderBookGet200Response:  # noqa: E501
        ...

    @validate_arguments
    def instruments_instrument_order_book_get(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, time : Annotated[Optional[StrictStr], Field(description="The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched.")] = None, **kwargs) -> Union[InstrumentsInstrumentOrderBookGet200Response, Awaitable[InstrumentsInstrumentOrderBookGet200Response]]:  # noqa: E501
        """Get Order Book  # noqa: E501

        Fetch an order book for an instrument.  # noqa: E501

        >>> response = api.instruments_instrument_order_book_get(authorization, instrument, accept_datetime_format, time)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param instrument: Name of the Instrument (required)
        :type instrument: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param time: The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched.
        :type time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: InstrumentsInstrumentOrderBookGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the instruments_instrument_order_book_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.instruments_instrument_order_book_get_with_http_info(authorization, instrument, accept_datetime_format, time, **kwargs)  # noqa: E501

    @validate_arguments
    def instruments_instrument_order_book_get_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, time : Annotated[Optional[StrictStr], Field(description="The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Order Book  # noqa: E501

        Fetch an order book for an instrument.  # noqa: E501

        >>> response = api.instruments_instrument_order_book_get_with_http_info(authorization, instrument, accept_datetime_format, time)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param instrument: Name of the Instrument (required)
        :type instrument: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param time: The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched.
        :type time: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(InstrumentsInstrumentOrderBookGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'instrument',
            'accept_datetime_format',
            'time'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method instruments_instrument_order_book_get" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['instrument']:
            _path_params['instrument'] = _params['instrument']


        # process the query parameters
        _query_params = []
        if _params.get('time') is not None:  # noqa: E501
            _query_params.append(('time', _params['time']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InstrumentsInstrumentOrderBookGet200Response",
            '400': "GetInstrumentCandles400Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/instruments/{instrument}/orderBook', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def instruments_instrument_position_book_get(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, time : Annotated[Optional[StrictStr], Field(description="The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched.")] = None, **kwargs) -> InstrumentsInstrumentPositionBookGet200Response:  # noqa: E501
        ...

    @overload
    def instruments_instrument_position_book_get(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, time : Annotated[Optional[StrictStr], Field(description="The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched.")] = None, **kwargs) -> InstrumentsInstrumentPositionBookGet200Response:  # noqa: E501
        ...

    @validate_arguments
    def instruments_instrument_position_book_get(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, time : Annotated[Optional[StrictStr], Field(description="The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched.")] = None, **kwargs) -> Union[InstrumentsInstrumentPositionBookGet200Response, Awaitable[InstrumentsInstrumentPositionBookGet200Response]]:  # noqa: E501
        """Get Position Book  # noqa: E501

        Fetch a position book for an instrument.  # noqa: E501

        >>> response = api.instruments_instrument_position_book_get(authorization, instrument, accept_datetime_format, time)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param instrument: Name of the Instrument (required)
        :type instrument: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param time: The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched.
        :type time: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: InstrumentsInstrumentPositionBookGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the instruments_instrument_position_book_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.instruments_instrument_position_book_get_with_http_info(authorization, instrument, accept_datetime_format, time, **kwargs)  # noqa: E501

    @validate_arguments
    def instruments_instrument_position_book_get_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], instrument : Annotated[StrictStr, Field(..., description="Name of the Instrument")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, time : Annotated[Optional[StrictStr], Field(description="The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Position Book  # noqa: E501

        Fetch a position book for an instrument.  # noqa: E501

        >>> response = api.instruments_instrument_position_book_get_with_http_info(authorization, instrument, accept_datetime_format, time)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param instrument: Name of the Instrument (required)
        :type instrument: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param time: The time of the snapshot to fetch. If not specified, then the most recent snapshot is fetched.
        :type time: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(InstrumentsInstrumentPositionBookGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'instrument',
            'accept_datetime_format',
            'time'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method instruments_instrument_position_book_get" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['instrument']:
            _path_params['instrument'] = _params['instrument']


        # process the query parameters
        _query_params = []
        if _params.get('time') is not None:  # noqa: E501
            _query_params.append(('time', _params['time']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "InstrumentsInstrumentPositionBookGet200Response",
            '400': "GetInstrumentCandles400Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/instruments/{instrument}/positionBook', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def list_accounts(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], **kwargs) -> ListAccounts200Response:  # noqa: E501
        ...

    @overload
    def list_accounts(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], **kwargs) -> ListAccounts200Response:  # noqa: E501
        ...

    @validate_arguments
    def list_accounts(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], **kwargs) -> Union[ListAccounts200Response, Awaitable[ListAccounts200Response]]:  # noqa: E501
        """List Accounts  # noqa: E501

        Get a list of all Accounts authorized for the provided token.  # noqa: E501

        >>> response = api.list_accounts(authorization)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: ListAccounts200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the list_accounts_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.list_accounts_with_http_info(authorization, **kwargs)  # noqa: E501

    @validate_arguments
    def list_accounts_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], **kwargs) -> ApiResponse:  # noqa: E501
        """List Accounts  # noqa: E501

        Get a list of all Accounts authorized for the provided token.  # noqa: E501

        >>> response = api.list_accounts_with_http_info(authorization)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(ListAccounts200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method list_accounts" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ListAccounts200Response",
            '401': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def list_open_positions(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], **kwargs) -> ListOpenPositions200Response:  # noqa: E501
        ...

    @overload
    def list_open_positions(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], **kwargs) -> ListOpenPositions200Response:  # noqa: E501
        ...

    @validate_arguments
    def list_open_positions(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], **kwargs) -> Union[ListOpenPositions200Response, Awaitable[ListOpenPositions200Response]]:  # noqa: E501
        """Open Positions  # noqa: E501

        List all open Positions for an Account. An open Position is a Position in an Account that currently has a Trade opened for it.  # noqa: E501

        >>> response = api.list_open_positions(authorization, account_id)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: ListOpenPositions200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the list_open_positions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.list_open_positions_with_http_info(authorization, account_id, **kwargs)  # noqa: E501

    @validate_arguments
    def list_open_positions_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], **kwargs) -> ApiResponse:  # noqa: E501
        """Open Positions  # noqa: E501

        List all open Positions for an Account. An open Position is a Position in an Account that currently has a Trade opened for it.  # noqa: E501

        >>> response = api.list_open_positions_with_http_info(authorization, account_id)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(ListOpenPositions200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method list_open_positions" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ListOpenPositions200Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/openPositions', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def list_open_trades(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> ListOpenTrades200Response:  # noqa: E501
        ...

    @overload
    def list_open_trades(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> ListOpenTrades200Response:  # noqa: E501
        ...

    @validate_arguments
    def list_open_trades(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> Union[ListOpenTrades200Response, Awaitable[ListOpenTrades200Response]]:  # noqa: E501
        """List Open Trades  # noqa: E501

        Get the list of open Trades for an Account  # noqa: E501

        >>> response = api.list_open_trades(authorization, account_id, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: ListOpenTrades200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the list_open_trades_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.list_open_trades_with_http_info(authorization, account_id, accept_datetime_format, **kwargs)  # noqa: E501

    @validate_arguments
    def list_open_trades_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List Open Trades  # noqa: E501

        Get the list of open Trades for an Account  # noqa: E501

        >>> response = api.list_open_trades_with_http_info(authorization, account_id, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(ListOpenTrades200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'accept_datetime_format'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method list_open_trades" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ListOpenTrades200Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/openTrades', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def list_orders(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, ids : Annotated[Optional[conlist(StrictStr)], Field(description="List of Order IDs to retrieve")] = None, state : Annotated[Optional[StrictStr], Field(description="The state to filter the requested Orders by")] = None, instrument : Annotated[Optional[StrictStr], Field(description="The instrument to filter the requested orders by")] = None, count : Annotated[Optional[StrictInt], Field(description="The maximum number of Orders to return")] = None, before_id : Annotated[Optional[StrictStr], Field(description="The maximum Order ID to return. If not provided the most recent Orders in the Account are returned")] = None, **kwargs) -> ListOrders200Response:  # noqa: E501
        ...

    @overload
    def list_orders(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, ids : Annotated[Optional[conlist(StrictStr)], Field(description="List of Order IDs to retrieve")] = None, state : Annotated[Optional[StrictStr], Field(description="The state to filter the requested Orders by")] = None, instrument : Annotated[Optional[StrictStr], Field(description="The instrument to filter the requested orders by")] = None, count : Annotated[Optional[StrictInt], Field(description="The maximum number of Orders to return")] = None, before_id : Annotated[Optional[StrictStr], Field(description="The maximum Order ID to return. If not provided the most recent Orders in the Account are returned")] = None, **kwargs) -> ListOrders200Response:  # noqa: E501
        ...

    @validate_arguments
    def list_orders(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, ids : Annotated[Optional[conlist(StrictStr)], Field(description="List of Order IDs to retrieve")] = None, state : Annotated[Optional[StrictStr], Field(description="The state to filter the requested Orders by")] = None, instrument : Annotated[Optional[StrictStr], Field(description="The instrument to filter the requested orders by")] = None, count : Annotated[Optional[StrictInt], Field(description="The maximum number of Orders to return")] = None, before_id : Annotated[Optional[StrictStr], Field(description="The maximum Order ID to return. If not provided the most recent Orders in the Account are returned")] = None, **kwargs) -> Union[ListOrders200Response, Awaitable[ListOrders200Response]]:  # noqa: E501
        """List Orders  # noqa: E501

        Get a list of Orders for an Account  # noqa: E501

        >>> response = api.list_orders(authorization, account_id, accept_datetime_format, ids, state, instrument, count, before_id)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param ids: List of Order IDs to retrieve
        :type ids: List[str]
        :param state: The state to filter the requested Orders by
        :type state: str
        :param instrument: The instrument to filter the requested orders by
        :type instrument: str
        :param count: The maximum number of Orders to return
        :type count: int
        :param before_id: The maximum Order ID to return. If not provided the most recent Orders in the Account are returned
        :type before_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: ListOrders200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the list_orders_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.list_orders_with_http_info(authorization, account_id, accept_datetime_format, ids, state, instrument, count, before_id, **kwargs)  # noqa: E501

    @validate_arguments
    def list_orders_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, ids : Annotated[Optional[conlist(StrictStr)], Field(description="List of Order IDs to retrieve")] = None, state : Annotated[Optional[StrictStr], Field(description="The state to filter the requested Orders by")] = None, instrument : Annotated[Optional[StrictStr], Field(description="The instrument to filter the requested orders by")] = None, count : Annotated[Optional[StrictInt], Field(description="The maximum number of Orders to return")] = None, before_id : Annotated[Optional[StrictStr], Field(description="The maximum Order ID to return. If not provided the most recent Orders in the Account are returned")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List Orders  # noqa: E501

        Get a list of Orders for an Account  # noqa: E501

        >>> response = api.list_orders_with_http_info(authorization, account_id, accept_datetime_format, ids, state, instrument, count, before_id)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param ids: List of Order IDs to retrieve
        :type ids: List[str]
        :param state: The state to filter the requested Orders by
        :type state: str
        :param instrument: The instrument to filter the requested orders by
        :type instrument: str
        :param count: The maximum number of Orders to return
        :type count: int
        :param before_id: The maximum Order ID to return. If not provided the most recent Orders in the Account are returned
        :type before_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(ListOrders200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'accept_datetime_format',
            'ids',
            'state',
            'instrument',
            'count',
            'before_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method list_orders" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']


        # process the query parameters
        _query_params = []
        if _params.get('ids') is not None:  # noqa: E501
            _query_params.append(('ids', _params['ids']))
            _collection_formats['ids'] = 'csv'

        if _params.get('state') is not None:  # noqa: E501
            _query_params.append(('state', _params['state']))

        if _params.get('instrument') is not None:  # noqa: E501
            _query_params.append(('instrument', _params['instrument']))

        if _params.get('count') is not None:  # noqa: E501
            _query_params.append(('count', _params['count']))

        if _params.get('before_id') is not None:  # noqa: E501
            _query_params.append(('beforeID', _params['before_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ListOrders200Response",
            '400': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/orders', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def list_pending_orders(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> ListPendingOrders200Response:  # noqa: E501
        ...

    @overload
    def list_pending_orders(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> ListPendingOrders200Response:  # noqa: E501
        ...

    @validate_arguments
    def list_pending_orders(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> Union[ListPendingOrders200Response, Awaitable[ListPendingOrders200Response]]:  # noqa: E501
        """Pending Orders  # noqa: E501

        List all pending Orders in an Account  # noqa: E501

        >>> response = api.list_pending_orders(authorization, account_id, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: ListPendingOrders200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the list_pending_orders_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.list_pending_orders_with_http_info(authorization, account_id, accept_datetime_format, **kwargs)  # noqa: E501

    @validate_arguments
    def list_pending_orders_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Pending Orders  # noqa: E501

        List all pending Orders in an Account  # noqa: E501

        >>> response = api.list_pending_orders_with_http_info(authorization, account_id, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(ListPendingOrders200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'accept_datetime_format'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method list_pending_orders" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ListPendingOrders200Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/pendingOrders', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def list_positions(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], **kwargs) -> ListPositions200Response:  # noqa: E501
        ...

    @overload
    def list_positions(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], **kwargs) -> ListPositions200Response:  # noqa: E501
        ...

    @validate_arguments
    def list_positions(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], **kwargs) -> Union[ListPositions200Response, Awaitable[ListPositions200Response]]:  # noqa: E501
        """List Positions  # noqa: E501

        List all Positions for an Account. The Positions returned are for every instrument that has had a position during the lifetime of an the Account.  # noqa: E501

        >>> response = api.list_positions(authorization, account_id)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: ListPositions200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the list_positions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.list_positions_with_http_info(authorization, account_id, **kwargs)  # noqa: E501

    @validate_arguments
    def list_positions_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], **kwargs) -> ApiResponse:  # noqa: E501
        """List Positions  # noqa: E501

        List all Positions for an Account. The Positions returned are for every instrument that has had a position during the lifetime of an the Account.  # noqa: E501

        >>> response = api.list_positions_with_http_info(authorization, account_id)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(ListPositions200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method list_positions" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ListPositions200Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/positions', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def list_trades(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, ids : Annotated[Optional[conlist(StrictStr)], Field(description="List of Trade IDs to retrieve.")] = None, state : Annotated[Optional[StrictStr], Field(description="The state to filter the requested Trades by.")] = None, instrument : Annotated[Optional[StrictStr], Field(description="The instrument to filter the requested Trades by.")] = None, count : Annotated[Optional[StrictInt], Field(description="The maximum number of Trades to return.")] = None, before_id : Annotated[Optional[StrictStr], Field(description="The maximum Trade ID to return. If not provided the most recent Trades in the Account are returned.")] = None, **kwargs) -> ListTrades200Response:  # noqa: E501
        ...

    @overload
    def list_trades(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, ids : Annotated[Optional[conlist(StrictStr)], Field(description="List of Trade IDs to retrieve.")] = None, state : Annotated[Optional[StrictStr], Field(description="The state to filter the requested Trades by.")] = None, instrument : Annotated[Optional[StrictStr], Field(description="The instrument to filter the requested Trades by.")] = None, count : Annotated[Optional[StrictInt], Field(description="The maximum number of Trades to return.")] = None, before_id : Annotated[Optional[StrictStr], Field(description="The maximum Trade ID to return. If not provided the most recent Trades in the Account are returned.")] = None, **kwargs) -> ListTrades200Response:  # noqa: E501
        ...

    @validate_arguments
    def list_trades(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, ids : Annotated[Optional[conlist(StrictStr)], Field(description="List of Trade IDs to retrieve.")] = None, state : Annotated[Optional[StrictStr], Field(description="The state to filter the requested Trades by.")] = None, instrument : Annotated[Optional[StrictStr], Field(description="The instrument to filter the requested Trades by.")] = None, count : Annotated[Optional[StrictInt], Field(description="The maximum number of Trades to return.")] = None, before_id : Annotated[Optional[StrictStr], Field(description="The maximum Trade ID to return. If not provided the most recent Trades in the Account are returned.")] = None, **kwargs) -> Union[ListTrades200Response, Awaitable[ListTrades200Response]]:  # noqa: E501
        """List Trades  # noqa: E501

        Get a list of Trades for an Account  # noqa: E501

        >>> response = api.list_trades(authorization, account_id, accept_datetime_format, ids, state, instrument, count, before_id)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param ids: List of Trade IDs to retrieve.
        :type ids: List[str]
        :param state: The state to filter the requested Trades by.
        :type state: str
        :param instrument: The instrument to filter the requested Trades by.
        :type instrument: str
        :param count: The maximum number of Trades to return.
        :type count: int
        :param before_id: The maximum Trade ID to return. If not provided the most recent Trades in the Account are returned.
        :type before_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: ListTrades200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the list_trades_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.list_trades_with_http_info(authorization, account_id, accept_datetime_format, ids, state, instrument, count, before_id, **kwargs)  # noqa: E501

    @validate_arguments
    def list_trades_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, ids : Annotated[Optional[conlist(StrictStr)], Field(description="List of Trade IDs to retrieve.")] = None, state : Annotated[Optional[StrictStr], Field(description="The state to filter the requested Trades by.")] = None, instrument : Annotated[Optional[StrictStr], Field(description="The instrument to filter the requested Trades by.")] = None, count : Annotated[Optional[StrictInt], Field(description="The maximum number of Trades to return.")] = None, before_id : Annotated[Optional[StrictStr], Field(description="The maximum Trade ID to return. If not provided the most recent Trades in the Account are returned.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List Trades  # noqa: E501

        Get a list of Trades for an Account  # noqa: E501

        >>> response = api.list_trades_with_http_info(authorization, account_id, accept_datetime_format, ids, state, instrument, count, before_id)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param ids: List of Trade IDs to retrieve.
        :type ids: List[str]
        :param state: The state to filter the requested Trades by.
        :type state: str
        :param instrument: The instrument to filter the requested Trades by.
        :type instrument: str
        :param count: The maximum number of Trades to return.
        :type count: int
        :param before_id: The maximum Trade ID to return. If not provided the most recent Trades in the Account are returned.
        :type before_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(ListTrades200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'accept_datetime_format',
            'ids',
            'state',
            'instrument',
            'count',
            'before_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method list_trades" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']


        # process the query parameters
        _query_params = []
        if _params.get('ids') is not None:  # noqa: E501
            _query_params.append(('ids', _params['ids']))
            _collection_formats['ids'] = 'csv'

        if _params.get('state') is not None:  # noqa: E501
            _query_params.append(('state', _params['state']))

        if _params.get('instrument') is not None:  # noqa: E501
            _query_params.append(('instrument', _params['instrument']))

        if _params.get('count') is not None:  # noqa: E501
            _query_params.append(('count', _params['count']))

        if _params.get('before_id') is not None:  # noqa: E501
            _query_params.append(('beforeID', _params['before_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ListTrades200Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/trades', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def list_transactions(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, var_from : Annotated[Optional[StrictStr], Field(description="The starting time (inclusive) of the time range for the Transactions being queried.")] = None, to : Annotated[Optional[StrictStr], Field(description="The ending time (inclusive) of the time range for the Transactions being queried.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="The number of Transactions to include in each page of the results.")] = None, type : Annotated[Optional[conlist(StrictStr)], Field(description="A filter for restricting the types of Transactions to retreive.")] = None, **kwargs) -> ListTransactions200Response:  # noqa: E501
        ...

    @overload
    def list_transactions(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, var_from : Annotated[Optional[StrictStr], Field(description="The starting time (inclusive) of the time range for the Transactions being queried.")] = None, to : Annotated[Optional[StrictStr], Field(description="The ending time (inclusive) of the time range for the Transactions being queried.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="The number of Transactions to include in each page of the results.")] = None, type : Annotated[Optional[conlist(StrictStr)], Field(description="A filter for restricting the types of Transactions to retreive.")] = None, **kwargs) -> ListTransactions200Response:  # noqa: E501
        ...

    @validate_arguments
    def list_transactions(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, var_from : Annotated[Optional[StrictStr], Field(description="The starting time (inclusive) of the time range for the Transactions being queried.")] = None, to : Annotated[Optional[StrictStr], Field(description="The ending time (inclusive) of the time range for the Transactions being queried.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="The number of Transactions to include in each page of the results.")] = None, type : Annotated[Optional[conlist(StrictStr)], Field(description="A filter for restricting the types of Transactions to retreive.")] = None, **kwargs) -> Union[ListTransactions200Response, Awaitable[ListTransactions200Response]]:  # noqa: E501
        """List Transactions  # noqa: E501

        Get a list of Transactions pages that satisfy a time-based Transaction query.  # noqa: E501

        >>> response = api.list_transactions(authorization, account_id, accept_datetime_format, var_from, to, page_size, type)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param var_from: The starting time (inclusive) of the time range for the Transactions being queried.
        :type var_from: str
        :param to: The ending time (inclusive) of the time range for the Transactions being queried.
        :type to: str
        :param page_size: The number of Transactions to include in each page of the results.
        :type page_size: int
        :param type: A filter for restricting the types of Transactions to retreive.
        :type type: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: ListTransactions200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the list_transactions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.list_transactions_with_http_info(authorization, account_id, accept_datetime_format, var_from, to, page_size, type, **kwargs)  # noqa: E501

    @validate_arguments
    def list_transactions_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, var_from : Annotated[Optional[StrictStr], Field(description="The starting time (inclusive) of the time range for the Transactions being queried.")] = None, to : Annotated[Optional[StrictStr], Field(description="The ending time (inclusive) of the time range for the Transactions being queried.")] = None, page_size : Annotated[Optional[StrictInt], Field(description="The number of Transactions to include in each page of the results.")] = None, type : Annotated[Optional[conlist(StrictStr)], Field(description="A filter for restricting the types of Transactions to retreive.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List Transactions  # noqa: E501

        Get a list of Transactions pages that satisfy a time-based Transaction query.  # noqa: E501

        >>> response = api.list_transactions_with_http_info(authorization, account_id, accept_datetime_format, var_from, to, page_size, type)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param var_from: The starting time (inclusive) of the time range for the Transactions being queried.
        :type var_from: str
        :param to: The ending time (inclusive) of the time range for the Transactions being queried.
        :type to: str
        :param page_size: The number of Transactions to include in each page of the results.
        :type page_size: int
        :param type: A filter for restricting the types of Transactions to retreive.
        :type type: List[str]
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(ListTransactions200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'accept_datetime_format',
            'var_from',
            'to',
            'page_size',
            'type'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method list_transactions" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']


        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            _query_params.append(('to', _params['to']))

        if _params.get('page_size') is not None:  # noqa: E501
            _query_params.append(('pageSize', _params['page_size']))

        if _params.get('type') is not None:  # noqa: E501
            _query_params.append(('type', _params['type']))
            _collection_formats['type'] = 'csv'

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "ListTransactions200Response",
            '400': "GetInstrumentCandles400Response",
            '401': "GetInstrumentCandles400Response",
            '403': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
            '416': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/transactions', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def replace_order(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], order_specifier : Annotated[StrictStr, Field(..., description="The Order Specifier")], replace_order_body : Annotated[CreateOrderRequest, Field(..., description="Specification of the replacing Order. The replacing order must have the same type as the replaced Order.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, client_request_id : Annotated[Optional[StrictStr], Field(description="Client specified RequestID to be sent with request.")] = None, **kwargs) -> ReplaceOrder201Response:  # noqa: E501
        ...

    @overload
    def replace_order(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], order_specifier : Annotated[StrictStr, Field(..., description="The Order Specifier")], replace_order_body : Annotated[CreateOrderRequest, Field(..., description="Specification of the replacing Order. The replacing order must have the same type as the replaced Order.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, client_request_id : Annotated[Optional[StrictStr], Field(description="Client specified RequestID to be sent with request.")] = None, **kwargs) -> ReplaceOrder201Response:  # noqa: E501
        ...

    @validate_arguments
    def replace_order(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], order_specifier : Annotated[StrictStr, Field(..., description="The Order Specifier")], replace_order_body : Annotated[CreateOrderRequest, Field(..., description="Specification of the replacing Order. The replacing order must have the same type as the replaced Order.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, client_request_id : Annotated[Optional[StrictStr], Field(description="Client specified RequestID to be sent with request.")] = None, **kwargs) -> Union[ReplaceOrder201Response, Awaitable[ReplaceOrder201Response]]:  # noqa: E501
        """Replace Order  # noqa: E501

        Replace an Order in an Account by simultaneously cancelling it and creating a replacement Order  # noqa: E501

        >>> response = api.replace_order(authorization, account_id, order_specifier, replace_order_body, accept_datetime_format, client_request_id)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param order_specifier: The Order Specifier (required)
        :type order_specifier: str
        :param replace_order_body: Specification of the replacing Order. The replacing order must have the same type as the replaced Order. (required)
        :type replace_order_body: CreateOrderRequest
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param client_request_id: Client specified RequestID to be sent with request.
        :type client_request_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: ReplaceOrder201Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the replace_order_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.replace_order_with_http_info(authorization, account_id, order_specifier, replace_order_body, accept_datetime_format, client_request_id, **kwargs)  # noqa: E501

    @validate_arguments
    def replace_order_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], order_specifier : Annotated[StrictStr, Field(..., description="The Order Specifier")], replace_order_body : Annotated[CreateOrderRequest, Field(..., description="Specification of the replacing Order. The replacing order must have the same type as the replaced Order.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, client_request_id : Annotated[Optional[StrictStr], Field(description="Client specified RequestID to be sent with request.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Replace Order  # noqa: E501

        Replace an Order in an Account by simultaneously cancelling it and creating a replacement Order  # noqa: E501

        >>> response = api.replace_order_with_http_info(authorization, account_id, order_specifier, replace_order_body, accept_datetime_format, client_request_id)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param order_specifier: The Order Specifier (required)
        :type order_specifier: str
        :param replace_order_body: Specification of the replacing Order. The replacing order must have the same type as the replaced Order. (required)
        :type replace_order_body: CreateOrderRequest
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param client_request_id: Client specified RequestID to be sent with request.
        :type client_request_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(ReplaceOrder201Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'order_specifier',
            'replace_order_body',
            'accept_datetime_format',
            'client_request_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method replace_order" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']

        if _params['order_specifier']:
            _path_params['orderSpecifier'] = _params['order_specifier']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        if _params['client_request_id']:
            _header_params['ClientRequestID'] = _params['client_request_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['replace_order_body'] is not None:
            _body_params = _params['replace_order_body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '201': "ReplaceOrder201Response",
            '400': "ReplaceOrder400Response",
            '401': "GetInstrumentCandles400Response",
            '404': "ReplaceOrder404Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/orders/{orderSpecifier}', RequestMethod.PUT,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def set_order_client_extensions(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], order_specifier : Annotated[StrictStr, Field(..., description="The Order Specifier")], set_order_client_extensions_body : Annotated[SetOrderClientExtensionsRequest, Field(..., description="Representation of the replacing Order")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> SetOrderClientExtensions200Response:  # noqa: E501
        ...

    @overload
    def set_order_client_extensions(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], order_specifier : Annotated[StrictStr, Field(..., description="The Order Specifier")], set_order_client_extensions_body : Annotated[SetOrderClientExtensionsRequest, Field(..., description="Representation of the replacing Order")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> SetOrderClientExtensions200Response:  # noqa: E501
        ...

    @validate_arguments
    def set_order_client_extensions(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], order_specifier : Annotated[StrictStr, Field(..., description="The Order Specifier")], set_order_client_extensions_body : Annotated[SetOrderClientExtensionsRequest, Field(..., description="Representation of the replacing Order")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> Union[SetOrderClientExtensions200Response, Awaitable[SetOrderClientExtensions200Response]]:  # noqa: E501
        """Set Order Extensions  # noqa: E501

        Update the Client Extensions for an Order in an Account. Do not set, modify, or delete clientExtensions if your account is associated with MT4.  # noqa: E501

        >>> response = api.set_order_client_extensions(authorization, account_id, order_specifier, set_order_client_extensions_body, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param order_specifier: The Order Specifier (required)
        :type order_specifier: str
        :param set_order_client_extensions_body: Representation of the replacing Order (required)
        :type set_order_client_extensions_body: SetOrderClientExtensionsRequest
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: SetOrderClientExtensions200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the set_order_client_extensions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.set_order_client_extensions_with_http_info(authorization, account_id, order_specifier, set_order_client_extensions_body, accept_datetime_format, **kwargs)  # noqa: E501

    @validate_arguments
    def set_order_client_extensions_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], order_specifier : Annotated[StrictStr, Field(..., description="The Order Specifier")], set_order_client_extensions_body : Annotated[SetOrderClientExtensionsRequest, Field(..., description="Representation of the replacing Order")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Set Order Extensions  # noqa: E501

        Update the Client Extensions for an Order in an Account. Do not set, modify, or delete clientExtensions if your account is associated with MT4.  # noqa: E501

        >>> response = api.set_order_client_extensions_with_http_info(authorization, account_id, order_specifier, set_order_client_extensions_body, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param order_specifier: The Order Specifier (required)
        :type order_specifier: str
        :param set_order_client_extensions_body: Representation of the replacing Order (required)
        :type set_order_client_extensions_body: SetOrderClientExtensionsRequest
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(SetOrderClientExtensions200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'order_specifier',
            'set_order_client_extensions_body',
            'accept_datetime_format'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method set_order_client_extensions" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']

        if _params['order_specifier']:
            _path_params['orderSpecifier'] = _params['order_specifier']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['set_order_client_extensions_body'] is not None:
            _body_params = _params['set_order_client_extensions_body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SetOrderClientExtensions200Response",
            '400': "SetOrderClientExtensions400Response",
            '401': "GetInstrumentCandles400Response",
            '404': "SetOrderClientExtensions404Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/orders/{orderSpecifier}/clientExtensions', RequestMethod.PUT,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def set_trade_client_extensions(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], trade_specifier : Annotated[StrictStr, Field(..., description="Specifier for the Trade")], set_trade_client_extensions_body : Annotated[SetTradeClientExtensionsRequest, Field(..., description="Details of how to modify the Trade's Client Extensions.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> SetTradeClientExtensions200Response:  # noqa: E501
        ...

    @overload
    def set_trade_client_extensions(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], trade_specifier : Annotated[StrictStr, Field(..., description="Specifier for the Trade")], set_trade_client_extensions_body : Annotated[SetTradeClientExtensionsRequest, Field(..., description="Details of how to modify the Trade's Client Extensions.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> SetTradeClientExtensions200Response:  # noqa: E501
        ...

    @validate_arguments
    def set_trade_client_extensions(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], trade_specifier : Annotated[StrictStr, Field(..., description="Specifier for the Trade")], set_trade_client_extensions_body : Annotated[SetTradeClientExtensionsRequest, Field(..., description="Details of how to modify the Trade's Client Extensions.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> Union[SetTradeClientExtensions200Response, Awaitable[SetTradeClientExtensions200Response]]:  # noqa: E501
        """Set Trade Client Extensions  # noqa: E501

        Update the Client Extensions for a Trade. Do not add, update, or delete the Client Extensions if your account is associated with MT4.  # noqa: E501

        >>> response = api.set_trade_client_extensions(authorization, account_id, trade_specifier, set_trade_client_extensions_body, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param trade_specifier: Specifier for the Trade (required)
        :type trade_specifier: str
        :param set_trade_client_extensions_body: Details of how to modify the Trade's Client Extensions. (required)
        :type set_trade_client_extensions_body: SetTradeClientExtensionsRequest
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: SetTradeClientExtensions200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the set_trade_client_extensions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.set_trade_client_extensions_with_http_info(authorization, account_id, trade_specifier, set_trade_client_extensions_body, accept_datetime_format, **kwargs)  # noqa: E501

    @validate_arguments
    def set_trade_client_extensions_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], trade_specifier : Annotated[StrictStr, Field(..., description="Specifier for the Trade")], set_trade_client_extensions_body : Annotated[SetTradeClientExtensionsRequest, Field(..., description="Details of how to modify the Trade's Client Extensions.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Set Trade Client Extensions  # noqa: E501

        Update the Client Extensions for a Trade. Do not add, update, or delete the Client Extensions if your account is associated with MT4.  # noqa: E501

        >>> response = api.set_trade_client_extensions_with_http_info(authorization, account_id, trade_specifier, set_trade_client_extensions_body, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param trade_specifier: Specifier for the Trade (required)
        :type trade_specifier: str
        :param set_trade_client_extensions_body: Details of how to modify the Trade's Client Extensions. (required)
        :type set_trade_client_extensions_body: SetTradeClientExtensionsRequest
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(SetTradeClientExtensions200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'trade_specifier',
            'set_trade_client_extensions_body',
            'accept_datetime_format'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method set_trade_client_extensions" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']

        if _params['trade_specifier']:
            _path_params['tradeSpecifier'] = _params['trade_specifier']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['set_trade_client_extensions_body'] is not None:
            _body_params = _params['set_trade_client_extensions_body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SetTradeClientExtensions200Response",
            '400': "SetTradeClientExtensions400Response",
            '401': "GetInstrumentCandles400Response",
            '404': "SetTradeClientExtensions404Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/trades/{tradeSpecifier}/clientExtensions', RequestMethod.PUT,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def set_trade_dependent_orders(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], trade_specifier : Annotated[StrictStr, Field(..., description="Specifier for the Trade")], set_trade_dependent_orders_body : Annotated[SetTradeDependentOrdersRequest, Field(..., description="Details of how to modify the Trade's dependent Orders.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> SetTradeDependentOrders200Response:  # noqa: E501
        ...

    @overload
    def set_trade_dependent_orders(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], trade_specifier : Annotated[StrictStr, Field(..., description="Specifier for the Trade")], set_trade_dependent_orders_body : Annotated[SetTradeDependentOrdersRequest, Field(..., description="Details of how to modify the Trade's dependent Orders.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> SetTradeDependentOrders200Response:  # noqa: E501
        ...

    @validate_arguments
    def set_trade_dependent_orders(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], trade_specifier : Annotated[StrictStr, Field(..., description="Specifier for the Trade")], set_trade_dependent_orders_body : Annotated[SetTradeDependentOrdersRequest, Field(..., description="Details of how to modify the Trade's dependent Orders.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> Union[SetTradeDependentOrders200Response, Awaitable[SetTradeDependentOrders200Response]]:  # noqa: E501
        """Set Dependent Orders  # noqa: E501

        Create, replace and cancel a Trade's dependent Orders (Take Profit, Stop Loss and Trailing Stop Loss) through the Trade itself  # noqa: E501

        >>> response = api.set_trade_dependent_orders(authorization, account_id, trade_specifier, set_trade_dependent_orders_body, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param trade_specifier: Specifier for the Trade (required)
        :type trade_specifier: str
        :param set_trade_dependent_orders_body: Details of how to modify the Trade's dependent Orders. (required)
        :type set_trade_dependent_orders_body: SetTradeDependentOrdersRequest
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: SetTradeDependentOrders200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the set_trade_dependent_orders_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.set_trade_dependent_orders_with_http_info(authorization, account_id, trade_specifier, set_trade_dependent_orders_body, accept_datetime_format, **kwargs)  # noqa: E501

    @validate_arguments
    def set_trade_dependent_orders_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], trade_specifier : Annotated[StrictStr, Field(..., description="Specifier for the Trade")], set_trade_dependent_orders_body : Annotated[SetTradeDependentOrdersRequest, Field(..., description="Details of how to modify the Trade's dependent Orders.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Set Dependent Orders  # noqa: E501

        Create, replace and cancel a Trade's dependent Orders (Take Profit, Stop Loss and Trailing Stop Loss) through the Trade itself  # noqa: E501

        >>> response = api.set_trade_dependent_orders_with_http_info(authorization, account_id, trade_specifier, set_trade_dependent_orders_body, accept_datetime_format)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param trade_specifier: Specifier for the Trade (required)
        :type trade_specifier: str
        :param set_trade_dependent_orders_body: Details of how to modify the Trade's dependent Orders. (required)
        :type set_trade_dependent_orders_body: SetTradeDependentOrdersRequest
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(SetTradeDependentOrders200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'trade_specifier',
            'set_trade_dependent_orders_body',
            'accept_datetime_format'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method set_trade_dependent_orders" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']

        if _params['trade_specifier']:
            _path_params['tradeSpecifier'] = _params['trade_specifier']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['set_trade_dependent_orders_body'] is not None:
            _body_params = _params['set_trade_dependent_orders_body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SetTradeDependentOrders200Response",
            '400': "SetTradeDependentOrders400Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/trades/{tradeSpecifier}/orders', RequestMethod.PUT,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def stream_pricing(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], instruments : Annotated[conlist(StrictStr), Field(..., description="List of Instruments to stream Prices for.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, snapshot : Annotated[Optional[StrictBool], Field(description="Flag that enables/disables the sending of a pricing snapshot when initially connecting to the stream.")] = None, **kwargs) -> StreamPricing200Response:  # noqa: E501
        ...

    @overload
    def stream_pricing(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], instruments : Annotated[conlist(StrictStr), Field(..., description="List of Instruments to stream Prices for.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, snapshot : Annotated[Optional[StrictBool], Field(description="Flag that enables/disables the sending of a pricing snapshot when initially connecting to the stream.")] = None, **kwargs) -> StreamPricing200Response:  # noqa: E501
        ...

    @validate_arguments
    def stream_pricing(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], instruments : Annotated[conlist(StrictStr), Field(..., description="List of Instruments to stream Prices for.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, snapshot : Annotated[Optional[StrictBool], Field(description="Flag that enables/disables the sending of a pricing snapshot when initially connecting to the stream.")] = None, **kwargs) -> Union[StreamPricing200Response, Awaitable[StreamPricing200Response]]:  # noqa: E501
        """Price Stream  # noqa: E501

        Get a stream of Account Prices starting from when the request is made. This pricing stream does not include every single price created for the Account, but instead will provide at most 4 prices per second (every 250 milliseconds) for each instrument being requested. If more than one price is created for an instrument during the 250 millisecond window, only the price in effect at the end of the window is sent. This means that during periods of rapid price movement, subscribers to this stream will not be sent every price. Pricing windows for different connections to the price stream are not all aligned in the same way (i.e. they are not all aligned to the top of the second). This means that during periods of rapid price movement, different subscribers may observe different prices depending on their alignment.  # noqa: E501

        >>> response = api.stream_pricing(authorization, account_id, instruments, accept_datetime_format, snapshot)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param instruments: List of Instruments to stream Prices for. (required)
        :type instruments: List[str]
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param snapshot: Flag that enables/disables the sending of a pricing snapshot when initially connecting to the stream.
        :type snapshot: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: StreamPricing200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stream_pricing_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stream_pricing_with_http_info(authorization, account_id, instruments, accept_datetime_format, snapshot, **kwargs)  # noqa: E501

    @validate_arguments
    def stream_pricing_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], instruments : Annotated[conlist(StrictStr), Field(..., description="List of Instruments to stream Prices for.")], accept_datetime_format : Annotated[Optional[StrictStr], Field(description="Format of DateTime fields in the request and response.")] = None, snapshot : Annotated[Optional[StrictBool], Field(description="Flag that enables/disables the sending of a pricing snapshot when initially connecting to the stream.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Price Stream  # noqa: E501

        Get a stream of Account Prices starting from when the request is made. This pricing stream does not include every single price created for the Account, but instead will provide at most 4 prices per second (every 250 milliseconds) for each instrument being requested. If more than one price is created for an instrument during the 250 millisecond window, only the price in effect at the end of the window is sent. This means that during periods of rapid price movement, subscribers to this stream will not be sent every price. Pricing windows for different connections to the price stream are not all aligned in the same way (i.e. they are not all aligned to the top of the second). This means that during periods of rapid price movement, different subscribers may observe different prices depending on their alignment.  # noqa: E501

        >>> response = api.stream_pricing_with_http_info(authorization, account_id, instruments, accept_datetime_format, snapshot)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param instruments: List of Instruments to stream Prices for. (required)
        :type instruments: List[str]
        :param accept_datetime_format: Format of DateTime fields in the request and response.
        :type accept_datetime_format: str
        :param snapshot: Flag that enables/disables the sending of a pricing snapshot when initially connecting to the stream.
        :type snapshot: bool
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(StreamPricing200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id',
            'instruments',
            'accept_datetime_format',
            'snapshot'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method stream_pricing" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']


        # process the query parameters
        _query_params = []
        if _params.get('instruments') is not None:  # noqa: E501
            _query_params.append(('instruments', _params['instruments']))
            _collection_formats['instruments'] = 'csv'

        if _params.get('snapshot') is not None:  # noqa: E501
            _query_params.append(('snapshot', _params['snapshot']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        if _params['accept_datetime_format']:
            _header_params['Accept-Datetime-Format'] = _params['accept_datetime_format']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StreamPricing200Response",
            '400': "GetInstrumentCandles400Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/pricing/stream', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @overload
    async def stream_transactions(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], **kwargs) -> StreamTransactions200Response:  # noqa: E501
        ...

    @overload
    def stream_transactions(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], **kwargs) -> StreamTransactions200Response:  # noqa: E501
        ...

    @validate_arguments
    def stream_transactions(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], **kwargs) -> Union[StreamTransactions200Response, Awaitable[StreamTransactions200Response]]:  # noqa: E501
        """Transaction Stream  # noqa: E501

        Get a stream of Transactions for an Account starting from when the request is made.  # noqa: E501

        >>> response = api.stream_transactions(authorization, account_id)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the response object.
        :rtype: StreamTransactions200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the stream_transactions_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.stream_transactions_with_http_info(authorization, account_id, **kwargs)  # noqa: E501

    @validate_arguments
    def stream_transactions_with_http_info(self, authorization : Annotated[StrictStr, Field(..., description="The authorization bearer token previously obtained by the client")], account_id : Annotated[StrictStr, Field(..., description="Account Identifier")], **kwargs) -> ApiResponse:  # noqa: E501
        """Transaction Stream  # noqa: E501

        Get a stream of Transactions for an Account starting from when the request is made.  # noqa: E501

        >>> response = api.stream_transactions_with_http_info(authorization, account_id)

        :param authorization: The authorization bearer token previously obtained by the client (required)
        :type authorization: str
        :param account_id: Account Identifier (required)
        :type account_id: str
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the response object.
        :rtype: tuple(StreamTransactions200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'authorization',
            'account_id'
        ]
        _all_params.extend(
            [
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        if __debug__:
            # validate the arguments
            for _key, _val in _params['kwargs'].items():
                if _key not in _all_params:
                    raise ApiTypeError(
                        "Got an unexpected keyword argument '%s'"
                        " to method stream_transactions" % _key
                    )
                _params[_key] = _val
            del _params['kwargs']
        else:
            kw = _params['kwargs']
            del _params['kwargs']
            _params.update(kw)
            del kw

        _collection_formats = None

        # process the path parameters
        _path_params = {}
        if _params['account_id']:
            _path_params['accountID'] = _params['account_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['authorization']:
            _header_params['Authorization'] = _params['authorization']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "StreamTransactions200Response",
            '400': "GetInstrumentCandles400Response",
            '401': "GetInstrumentCandles400Response",
            '404': "GetInstrumentCandles400Response",
            '405': "GetInstrumentCandles400Response",
        }

        return self.api_client.call_api(
            '/accounts/{accountID}/transactions/stream', RequestMethod.GET,
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
